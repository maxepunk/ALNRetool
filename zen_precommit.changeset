diff --git a/CLAUDE.md b/CLAUDE.md
index 4dcdfe4..766b441 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -113,6 +113,9 @@ npx cz                  # Interactive commit with conventional format
 
 ## Important Patterns
 
+- In dev, you need to set origin as localhost for scripts/curl/etc to get through the auth middleware.
+- **Read the FULL file you are working with EVERY time to ensure you understand the context and structure of the code you're working on. **
+
 ### Simplified Graph Architecture (Post-Refactor)
 ```
 src/lib/graph/
diff --git a/DEPLOYMENT.md b/DEPLOYMENT.md
deleted file mode 100644
index 61bc544..0000000
--- a/DEPLOYMENT.md
+++ /dev/null
@@ -1,221 +0,0 @@
-# ALNRetool Deployment Guide
-
-## Deployment to Render.com
-
-### Prerequisites
-1. GitHub repository with the latest code
-2. Notion API key and database IDs
-3. Render.com account (free tier works)
-
-### Critical Environment Variable Configuration
-
-**⚠️ IMPORTANT**: The application follows 12-factor app principles. In production:
-- Environment variables MUST be set through the platform (Render dashboard)
-- The application will NOT load .env files in production (NODE_ENV=production)
-- Missing required variables will cause the server to fail fast and exit
-
-This prevents accidental override of production secrets by development .env files.
-
-### Step 1: Connect Repository
-1. Log in to [Render Dashboard](https://dashboard.render.com)
-2. Click "New +" → "Web Service"
-3. Connect your GitHub account if not already connected
-4. Select the `maxepunk/ALNRetool` repository
-5. Click "Connect"
-
-### Step 2: Configure Service
-Use these settings in the Render dashboard:
-
-- **Name**: `alnretool` (or your preferred name)
-- **Region**: Oregon (US West) or closest to you
-- **Branch**: `main` or `feature/sprint-1-foundation`
-- **Root Directory**: Leave empty (uses repository root)
-- **Runtime**: Node
-- **Build Command**: `npm install && npm run build`
-- **Start Command**: `npm run start`
-- **Instance Type**: Free
-
-### Step 3: Environment Variables
-Add these environment variables in Render dashboard:
-
-```
-NODE_ENV=production
-NOTION_API_KEY=your_notion_api_key_here
-FRONTEND_URL=https://alnretool.onrender.com
-
-# Database IDs (from Notion) - CRITICAL: Use exact field names
-NOTION_CHARACTERS_DB=18c2f33d-583f-8060-a6ab-de32ff06bca2
-NOTION_ELEMENTS_DB=18c2f33d-583f-8020-91bc-d84c7dd94306
-NOTION_PUZZLES_DB=1b62f33d-583f-80cc-87cf-d7d6c4b0b265
-NOTION_TIMELINE_DB=1b52f33d-583f-80de-ae5a-d20020c120dd
-```
-
-**⚠️ CRITICAL**: The database ID environment variables must match exactly what the code expects:
-- Use `NOTION_CHARACTERS_DB` not `NOTION_CHARACTER_DB_ID`
-- Use `NOTION_ELEMENTS_DB` not `NOTION_ELEMENT_DB_ID`
-- Use `NOTION_PUZZLES_DB` not `NOTION_PUZZLE_DB_ID`
-- Use `NOTION_TIMELINE_DB` not `NOTION_TIMELINE_DB_ID`
-
-### Step 4: Deploy
-1. Click "Create Web Service"
-2. Wait for the initial build and deploy (5-10 minutes)
-3. Your app will be available at `https://alnretool.onrender.com`
-
-### Step 5: Verify Deployment
-1. Visit `https://alnretool.onrender.com/healthz` - Should show "OK"
-2. Visit `https://alnretool.onrender.com/api/health` - Should show JSON status
-3. Visit `https://alnretool.onrender.com` - Should load the React app
-
-## Monitoring and Logs
-
-### View Logs
-- In Render dashboard, click on your service
-- Navigate to "Logs" tab
-- Monitor for any errors during startup or runtime
-
-### Common Issues and Solutions
-
-#### 1. Build Fails
-- Check Node version compatibility (requires Node 18+)
-- Verify all dependencies are in package.json
-- Check build logs for specific errors
-
-#### 2. App Crashes on Start
-- Verify all environment variables are set correctly (see Critical Environment Variables section)
-- Check if PORT is being overridden (Render sets this automatically)
-- Look for TypeScript compilation errors in logs
-
-#### 3. API Returns 500 Errors
-**Root Cause**: dotenv loading .env files in production and overriding platform variables
-
-**Solution**: The application now prevents dotenv from loading in production mode. Ensure:
-- `NODE_ENV=production` is set in Render environment variables
-- Never commit .env files to the repository (they should be in .gitignore)
-- All required environment variables are set in Render dashboard
-
-**Verification**: Check server logs for:
-- ✅ Good: `[Server] Production mode - Using platform environment variables (dotenv not loaded)`
-- ❌ Bad: `[dotenv@17.2.0] injecting env (11) from .env`
-
-#### 4. Missing Environment Variables
-The server now validates required variables at startup and will fail fast in production if any are missing:
-- `NOTION_API_KEY`
-- `NOTION_CHARACTERS_DB`
-- `NOTION_ELEMENTS_DB`
-- `NOTION_PUZZLES_DB`
-- `NOTION_TIMELINE_DB`
-
-#### 5. CORS Issues
-- Update FRONTEND_URL to match your Render URL
-- For custom domains, update FRONTEND_URL accordingly
-- In production, same-origin requests are allowed without API key
-
-## Automatic Deployments
-
-Render automatically deploys when you push to the connected branch:
-
-1. Make changes locally
-2. Commit and push to GitHub
-3. Render detects the push and starts a new deployment
-4. Monitor deployment progress in Render dashboard
-
-## Custom Domain (Optional)
-
-1. In Render dashboard, go to your service
-2. Click "Settings" → "Custom Domains"
-3. Add your domain and follow DNS configuration instructions
-
-## Performance Considerations
-
-### Free Tier Limitations
-- Service spins down after 15 minutes of inactivity
-- First request after spin-down takes 30-60 seconds
-- Limited to 750 hours/month across all services
-
-### Optimization Tips
-1. **Keep Warm**: Set up external monitoring to ping `/healthz` every 10 minutes
-2. **Cache Strategy**: Our 5-minute cache reduces Notion API calls
-3. **Bundle Size**: Monitor bundle size to ensure fast initial loads
-
-## Rollback Procedure
-
-If deployment issues occur:
-
-1. In Render dashboard, go to your service
-2. Click "Events" tab
-3. Find the last successful deploy
-4. Click "Rollback to this deploy"
-
-## Security Checklist
-
-- [x] API keys stored as environment variables
-- [x] CORS configured for production domain
-- [x] Rate limiting enabled (100 requests/minute)
-- [x] Authentication middleware on all Notion endpoints
-- [x] No sensitive data in client bundle
-- [x] HTTPS enforced by Render
-
-## Support and Monitoring
-
-### Health Endpoints
-- `/healthz` - Simple health check for uptime monitoring
-- `/api/health` - Detailed API health with timestamp
-- `/api/cache/stats` - Cache performance metrics (requires API key)
-
-### Recommended Monitoring
-1. **UptimeRobot** or **Pingdom** - Free tier available
-2. Set up monitoring for `/healthz` endpoint
-3. Alert on response time > 5 seconds or status != 200
-
-## Troubleshooting Production Issues
-
-### Debugging Steps
-1. **Check Server Logs First**
-   - Navigate to Render dashboard → Your Service → Logs
-   - Look for startup messages confirming environment configuration
-   - Check for any error messages or stack traces
-
-2. **Verify Environment Variables**
-   - In Render dashboard → Settings → Environment
-   - Confirm all 5 required variables are set
-   - Use exact variable names (e.g., `NOTION_CHARACTERS_DB` not `NOTION_CHARACTER_DB`)
-
-3. **Test API Endpoints**
-   ```bash
-   # Health check (should always work)
-   curl https://your-app.onrender.com/api/health
-   
-   # Test Notion endpoints (from same origin)
-   curl https://your-app.onrender.com/api/notion/characters?limit=1
-   ```
-
-4. **Check Browser Console**
-   - Open Developer Tools → Console
-   - Look for CORS errors or 500 responses
-   - Check Network tab for failed requests
-
-### Known Issues and Fixes
-- **Issue**: All API endpoints return 500 errors
-  - **Fix**: Ensure NODE_ENV=production and all NOTION_* variables are set in Render
-  
-- **Issue**: "Missing required environment variables" in logs
-  - **Fix**: Add missing variables in Render dashboard, redeploy
-
-- **Issue**: "[dotenv@...] injecting env" appears in production logs
-  - **Fix**: Update to latest code that prevents dotenv loading in production
-
-## Deployment Verification Checklist
-
-After deployment, verify:
-
-- [ ] Server logs show: "Production mode - Using platform environment variables"
-- [ ] Server logs show: "All required environment variables are configured ✓"
-- [ ] Homepage loads without errors
-- [ ] API health check returns OK
-- [ ] Can fetch character data
-- [ ] Can fetch element data  
-- [ ] Can fetch puzzle data
-- [ ] Can fetch timeline data
-- [ ] React Flow renders properly
-- [ ] No console errors in browser
-- [ ] Network requests use correct API endpoints
\ No newline at end of file
diff --git a/TD_ELIMINATE.md b/TD_ELIMINATE.md
deleted file mode 100644
index dc0b2fd..0000000
--- a/TD_ELIMINATE.md
+++ /dev/null
@@ -1,93 +0,0 @@
-# Tech Debt Elimination Status
-
-## Summary
-As of 2025-08-29, significant progress has been made on tech debt elimination tasks. This document tracks the actual implementation status.
-
-## Completed Tasks ✅
-
-### Task 1: Fix Critical Performance Issue with Global Cache Invalidation
-**Status: COMPLETE**
-- Fixed in `/server/routes/notion/createEntityRouter.ts` lines 99 & 134
-- Changed from `cacheService.invalidatePattern('*:*')` to surgical pattern invalidation
-- Now uses targeted patterns like `cacheService.invalidatePattern(\`*_${targetId}\`)`
-
-### Task 2: Fix Batch Mutation Cache Invalidation
-**Status: COMPLETE**
-- Fixed in `/src/hooks/mutations/entityMutations.ts` lines 737-748
-- Replaced `invalidateQueries` with surgical cache updates
-- Now properly updates individual entities and related caches
-
-### Task 3: Fix Delete Cleanup with Inverse Relations
-**Status: COMPLETE**
-- Fixed in `/server/routes/notion/createEntityRouter.ts` delete endpoint
-- Added proper inverse relationship cleanup when deleting entities
-- Added delete UI functionality to DetailPanel with confirmation dialog
-
-### Task 4: Optimize API Fetching with Promise.all
-**Status: COMPLETE**
-- Fixed character creation validation to fetch elements and puzzles in parallel
-- Fixed puzzle creation validation to use Promise.all pattern for consistency
-- Reduced API call latency by parallelizing independent fetches
-
-### Task 5: Remove Console Warnings
-**Status: COMPLETE**
-- Removed all console.warn statements from `/src/lib/graph/relationships.ts`
-- Missing entities now handled gracefully by skipping edge creation
-- No more console spam during graph rendering
-
-### Task 6: Fix TypeScript Type Safety
-**Status: COMPLETE**
-- Fixed 5 instances of `as any` type casts in entityMutations.ts
-- Replaced with proper TypeScript generics and type-safe reduce operations
-- Used Object.entries and spread operators for type-safe object manipulation
-
-### Task 7: Document Cache Patterns
-**Status: COMPLETE**
-- Added comprehensive cache management documentation to CLAUDE.md
-- Documented surgical invalidation patterns and best practices
-- Added examples of proper cache update strategies
-
-## Additional Improvements
-
-### Code Cleanup
-- Deleted unused `createPlaceholderNode` function and its extensive documentation
-- Removed unused imports and type references
-- Cleaned up comments referencing deprecated functionality
-
-### Developer Experience
-- Added inline ConfirmDialog component to DetailPanel (no external dependency)
-- Improved error handling and user feedback
-- Made code more maintainable with clear patterns
-
-## Remaining Work
-
-### Testing
-- Manual testing of all changes needed
-- Verify delete functionality works end-to-end
-- Confirm no console warnings appear during normal usage
-
-## Technical Notes
-
-### Cache Invalidation Strategy
-The key improvement was moving from nuclear cache invalidation (`*:*` pattern) to surgical updates:
-- Target specific entity IDs
-- Update only affected relationships
-- Preserve unrelated cached data
-
-### Type Safety Improvements
-Replaced unsafe type casts with proper TypeScript patterns:
-```typescript
-// Before (unsafe)
-(acc as any)[key] = value;
-
-// After (type-safe)
-return { ...acc, [key]: value };
-```
-
-### Performance Gains
-- Parallel API fetching reduces latency by ~50% for entity creation
-- Surgical cache updates prevent unnecessary re-fetches
-- Removal of console.warn eliminates performance overhead
-
-## Conclusion
-All 7 originally claimed tasks have now been properly completed, with additional improvements for code quality and maintainability.
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 2151298..a820042 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -40,6 +40,7 @@
       },
       "devDependencies": {
         "@eslint/js": "^9.30.1",
+        "@playwright/test": "^1.55.0",
         "@tailwindcss/postcss": "^4.1.12",
         "@testing-library/jest-dom": "^6.6.4",
         "@testing-library/react": "^14.3.1",
@@ -1843,6 +1844,22 @@
         "node": ">=14"
       }
     },
+    "node_modules/@playwright/test": {
+      "version": "1.55.0",
+      "resolved": "https://registry.npmjs.org/@playwright/test/-/test-1.55.0.tgz",
+      "integrity": "sha512-04IXzPwHrW69XusN/SIdDdKZBzMfOT9UNT/YiJit/xpy2VuAoB8NHc8Aplb96zsWDddLnbkPL3TsmrS04ZU2xQ==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "playwright": "1.55.0"
+      },
+      "bin": {
+        "playwright": "cli.js"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
     "node_modules/@polka/url": {
       "version": "1.0.0-next.29",
       "resolved": "https://registry.npmjs.org/@polka/url/-/url-1.0.0-next.29.tgz",
@@ -9356,6 +9373,53 @@
         "url": "https://github.com/sponsors/jonschlinkert"
       }
     },
+    "node_modules/playwright": {
+      "version": "1.55.0",
+      "resolved": "https://registry.npmjs.org/playwright/-/playwright-1.55.0.tgz",
+      "integrity": "sha512-sdCWStblvV1YU909Xqx0DhOjPZE4/5lJsIS84IfN9dAZfcl/CIZ5O8l3o0j7hPMjDvqoTF8ZUcc+i/GL5erstA==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "playwright-core": "1.55.0"
+      },
+      "bin": {
+        "playwright": "cli.js"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "optionalDependencies": {
+        "fsevents": "2.3.2"
+      }
+    },
+    "node_modules/playwright-core": {
+      "version": "1.55.0",
+      "resolved": "https://registry.npmjs.org/playwright-core/-/playwright-core-1.55.0.tgz",
+      "integrity": "sha512-GvZs4vU3U5ro2nZpeiwyb0zuFaqb9sUiAJuyrWpcGouD8y9/HLgGbNRjIph7zU9D3hnPaisMl9zG9CgFi/biIg==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "bin": {
+        "playwright-core": "cli.js"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
+    "node_modules/playwright/node_modules/fsevents": {
+      "version": "2.3.2",
+      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.2.tgz",
+      "integrity": "sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==",
+      "dev": true,
+      "hasInstallScript": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "darwin"
+      ],
+      "engines": {
+        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
+      }
+    },
     "node_modules/possible-typed-array-names": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/possible-typed-array-names/-/possible-typed-array-names-1.1.0.tgz",
diff --git a/package.json b/package.json
index 25a5bef..f4629ca 100644
--- a/package.json
+++ b/package.json
@@ -58,6 +58,7 @@
   },
   "devDependencies": {
     "@eslint/js": "^9.30.1",
+    "@playwright/test": "^1.55.0",
     "@tailwindcss/postcss": "^4.1.12",
     "@testing-library/jest-dom": "^6.6.4",
     "@testing-library/react": "^14.3.1",
diff --git a/server/index.ts b/server/index.ts
index 855d295..b6485eb 100644
--- a/server/index.ts
+++ b/server/index.ts
@@ -33,6 +33,7 @@ import cookieParser from 'cookie-parser';
 import rateLimit from 'express-rate-limit';
 import path from 'path';
 import notionRoutes from './routes/notion/index.js';
+import graphRoutes from './routes/graph.js';
 import cacheRoutes from './routes/cache.js';
 import { apiKeyAuth } from './middleware/auth.js';
 // CSRF middleware removed - using API key authentication only
@@ -169,6 +170,20 @@ app.get('/healthz', (req, res) => {
  */
 app.use('/api/notion', validatePagination, apiKeyAuth, notionRoutes);
 
+/**
+ * Graph API routes for complete graph data.
+ * Returns pre-computed nodes and edges with server-side relationship resolution.
+ * 
+ * @route /api/graph/*
+ * @protected Requires valid API key
+ * @middleware apiKeyAuth
+ * 
+ * **Available Endpoints:**
+ * - GET /api/graph/complete - Get complete graph with all nodes and edges
+ * - GET /api/graph/health - Health check for graph service
+ */
+app.use('/api/graph', apiKeyAuth, graphRoutes);
+
 /**
  * Cache management routes for manual cache control.
  * Protected with API key authentication.
diff --git a/server/routes/cache.ts b/server/routes/cache.ts
index 6042e0a..77a30b4 100644
--- a/server/routes/cache.ts
+++ b/server/routes/cache.ts
@@ -77,60 +77,5 @@ router.post('/clear/:endpoint', asyncHandler(async (req: Request, res: Response)
   });
 }));
 
-/**
- * HEAD /api/cache/version
- * Returns cache version headers for synchronization
- * Lightweight endpoint for frontend version checking
- */
-router.head('/version', asyncHandler(async (req: Request, res: Response) => {
-  // Get client version from request
-  const clientVersion = req.headers['x-client-cache-version'] as string;
-  
-  // Set response headers
-  res.setHeader('X-Cache-Version', cacheService.getVersion());
-  
-  // Add entity-specific versions
-  const entityTypes = ['characters', 'elements', 'puzzles', 'timeline'];
-  for (const entityType of entityTypes) {
-    const entityVersion = cacheService.getEntityVersion(entityType, 'list');
-    if (entityVersion) {
-      res.setHeader(`X-Entity-Version-${entityType}`, entityVersion);
-    }
-  }
-  
-  // Compare versions
-  if (clientVersion) {
-    const isValid = cacheService.validateVersion(clientVersion);
-    res.setHeader('X-Cache-Valid', isValid ? 'true' : 'false');
-  }
-  
-  // Send empty response (HEAD request)
-  res.end();
-}));
-
-/**
- * GET /api/cache/version
- * Returns cache version information in JSON
- */
-router.get('/version', asyncHandler(async (req: Request, res: Response) => {
-  const metadata = cacheService.getCacheMetadata();
-  const entityVersions: Record<string, string> = {};
-  
-  // Collect entity versions
-  const entityTypes = ['characters', 'elements', 'puzzles', 'timeline'];
-  for (const entityType of entityTypes) {
-    const version = cacheService.getEntityVersion(entityType, 'list');
-    if (version) {
-      entityVersions[entityType] = version;
-    }
-  }
-  
-  res.json({
-    globalVersion: cacheService.getVersion(),
-    entityVersions,
-    metadata,
-    timestamp: new Date().toISOString()
-  });
-}));
 
 export default router;
\ No newline at end of file
diff --git a/server/routes/notion/base.ts b/server/routes/notion/base.ts
index fbeb35a..1c49f47 100644
--- a/server/routes/notion/base.ts
+++ b/server/routes/notion/base.ts
@@ -40,9 +40,7 @@ export async function handleCachedNotionRequest<T>(
     const cachedResponse = cacheService.get<APIResponse<T>>(cacheKey);
     if (cachedResponse) {
       res.setHeader('X-Cache-Hit', 'true');
-      res.setHeader('X-Cache-Version', cacheService.getVersion());
       res.setHeader('X-Entity-Type', endpointName);
-      res.setHeader('X-Entity-Version', cacheService.getEntityVersion(endpointName, 'list') || cacheService.getVersion());
       res.json(cachedResponse);
       return;
     }
@@ -59,9 +57,7 @@ export async function handleCachedNotionRequest<T>(
 
   cacheService.set(cacheKey, response);
   res.setHeader('X-Cache-Hit', 'false');
-  res.setHeader('X-Cache-Version', cacheService.getVersion());
   res.setHeader('X-Entity-Type', endpointName);
-  res.setHeader('X-Entity-Version', cacheService.getEntityVersion(endpointName, 'list') || cacheService.getVersion());
   res.json(response);
 }
 
diff --git a/server/routes/notion/characters.ts b/server/routes/notion/characters.ts
index 939f832..9fa9ab1 100644
--- a/server/routes/notion/characters.ts
+++ b/server/routes/notion/characters.ts
@@ -47,9 +47,16 @@ const CHARACTERS_DATABASE_ID = config.notionDatabaseIds.characters;
  */
 const ELEMENTS_DATABASE_ID = config.notionDatabaseIds.elements;
 
+/**
+ * Notion database ID for puzzles collection.
+ * Used for inverse relation updates.
+ * @constant {string}
+ */
+const PUZZLES_DATABASE_ID = config.notionDatabaseIds.puzzles;
+
 /**
  * Inverse relation configuration for characters.
- * Defines how character updates propagate to related elements.
+ * Defines how character updates propagate to related elements and puzzles.
  * 
  * @constant {InverseRelation[]} characterInverseRelations
  * 
@@ -58,12 +65,18 @@ const ELEMENTS_DATABASE_ID = config.notionDatabaseIds.elements;
  *    - Updates Element.Owner field
  *    - Many-to-one bidirectional (many elements can have one owner)
  * 
+ * 2. **characterPuzzleIds**: Puzzles this character can access
+ *    - Note: Puzzles don't have a reciprocal "Characters" field in Notion
+ *    - This is a one-way relationship from Character to Puzzle
+ *    - Bidirectional is set to false as puzzles can't update back
+ * 
  * Note: associatedElementIds is a rollup from timeline events
  * and cannot be directly edited, so no inverse relation is needed.
  * 
  * **Synchronization:**
  * When a character's owned elements change, the corresponding
  * element records are automatically updated to maintain consistency.
+ * Character-puzzle relationships are one-way only.
  */
 const characterInverseRelations: InverseRelation[] = [
   {
@@ -73,6 +86,9 @@ const characterInverseRelations: InverseRelation[] = [
     relationType: 'one-to-many',
     bidirectional: true
   }
+  // Note: characterPuzzleIds cannot have a bidirectional inverse relation
+  // because puzzles don't have a "Characters" field in the Notion schema.
+  // The relationship is handled during creation via _parentRelation logic.
 ];
 
 /**
diff --git a/server/routes/notion/createEntityRouter.ts b/server/routes/notion/createEntityRouter.ts
index 1199973..b8abf3e 100644
--- a/server/routes/notion/createEntityRouter.ts
+++ b/server/routes/notion/createEntityRouter.ts
@@ -142,6 +142,9 @@ async function updateInverseRelations<T>(
       }
     }
   }
+  
+  // Invalidate graph cache after inverse relations are updated
+  cacheService.invalidatePattern('graph_complete*');
 }
 
 /**
@@ -172,7 +175,6 @@ export function createEntityRouter<T>(config: EntityRouterConfig<T>) {
     
     if (cached) {
       res.setHeader('X-Cache-Hit', 'true');
-      res.setHeader('X-Cache-Version', cacheService.getVersion());
       return res.json(cached);
     }
     
@@ -184,7 +186,6 @@ export function createEntityRouter<T>(config: EntityRouterConfig<T>) {
     cacheService.set(cacheKey, transformed);
     
     res.setHeader('X-Cache-Hit', 'false');
-    res.setHeader('X-Cache-Version', cacheService.getVersion());
     res.json(transformed);
   }));
   
@@ -194,7 +195,21 @@ export function createEntityRouter<T>(config: EntityRouterConfig<T>) {
       // Extract parent relationship metadata from request
       const { _parentRelation, ...entityData } = req.body;
       
-      // Create the Notion page
+      // Handle parent relation if present - set relationship on child entity if needed
+      if (_parentRelation) {
+        const { parentType, parentId, fieldKey } = _parentRelation;
+        
+        // Special handling for relationships stored on the child entity
+        // For puzzle->character creation, the relationship is stored on the character
+        if (parentType === 'puzzle' && config.entityName === 'characters' && fieldKey === 'characterIds') {
+          // The relationship is actually stored as characterPuzzleIds on the character
+          entityData.characterPuzzleIds = [parentId];
+        }
+        // Add more child-side relationship mappings as needed
+        // e.g., timeline->character, element->element, etc.
+      }
+      
+      // Create the Notion page with potentially modified entity data
       const properties = config.toNotionProps!(entityData);
       const response = await notion.pages.create({
         parent: { database_id: config.databaseId },
@@ -205,12 +220,20 @@ export function createEntityRouter<T>(config: EntityRouterConfig<T>) {
       const transformed = config.transform(response);
       
       // If this was created from a parent relationship, update the parent atomically
-      if (_parentRelation) {
+      // Skip if we already handled the relationship on the child entity
+      const handledOnChild = _parentRelation && 
+        _parentRelation.parentType === 'puzzle' && 
+        config.entityName === 'characters' && 
+        _parentRelation.fieldKey === 'characterIds';
+      
+      if (_parentRelation && !handledOnChild) {
         const { parentType, parentId, fieldKey } = _parentRelation;
         
         try {
-          // Import the appropriate mapper function dynamically
+          // Import the appropriate mapper function and field mapping
           const mappers = await import('../../services/notionPropertyMappers.js');
+          const { FIELD_TO_NOTION_PROPERTY } = mappers;
+          
           // parentType is already singular from frontend ('element', 'character', 'puzzle', 'timeline')
           const mapperName = `toNotion${parentType.charAt(0).toUpperCase()}${parentType.slice(1)}Properties`;
           const parentMapper = (mappers as any)[mapperName];
@@ -222,11 +245,15 @@ export function createEntityRouter<T>(config: EntityRouterConfig<T>) {
           // Get the parent's current data
           const parentPage = await notion.pages.retrieve({ page_id: parentId }) as NotionPage;
           
-          // Get the correct Notion property name using the mapper
-          // Create a dummy update object to leverage the existing mapper logic
-          const dummyUpdate = { [fieldKey]: [] };
-          const mappedProps = parentMapper(dummyUpdate);
-          const notionPropertyName = Object.keys(mappedProps)[0];
+          // Get the correct Notion property name from explicit mapping
+          const typeMapping = FIELD_TO_NOTION_PROPERTY[parentType as keyof typeof FIELD_TO_NOTION_PROPERTY];
+          if (!typeMapping) {
+            throw new Error(`No mapping found for parent type: ${parentType}`);
+          }
+          const notionPropertyName = (typeMapping as any)[fieldKey];
+          if (!notionPropertyName) {
+            throw new Error(`No property mapping found for ${parentType}.${fieldKey}`);
+          }
           
           // Extract current relation IDs using the correct property name
           const currentRelation = parentPage.properties[notionPropertyName];
@@ -247,8 +274,12 @@ export function createEntityRouter<T>(config: EntityRouterConfig<T>) {
             properties: parentProperties
           });
           
-          // Invalidate parent entity cache
-          await cacheService.invalidateEntity(parentType, parentId);
+          // Invalidate parent entity cache  
+          cacheService.invalidatePattern(`${parentType}:*`);
+          cacheService.invalidatePattern(`${parentType}_${parentId}`);
+          
+          // Invalidate graph cache immediately since parent relationship changed
+          cacheService.invalidatePattern('graph_complete*');
         } catch (error) {
           // If parent update fails, delete the created entity to maintain atomicity
           log.error('Failed to update parent relation, rolling back entity creation', {
@@ -281,8 +312,11 @@ export function createEntityRouter<T>(config: EntityRouterConfig<T>) {
       
       // Invalidate list cache to ensure new entity appears
       // Must invalidate both collection keys (colon format) and single entity keys (underscore format)
-      await cacheService.invalidatePattern(`${config.entityName}:*`); // Collection caches: "elements:20:null"
-      await cacheService.invalidatePattern(`${config.entityName}_*`); // Single entity caches: "elements_abc123:20:null"
+      cacheService.invalidatePattern(`${config.entityName}:*`); // Collection caches: "elements:20:null"
+      cacheService.invalidatePattern(`${config.entityName}_*`); // Single entity caches: "elements_abc123:20:null"
+      
+      // Invalidate graph cache to ensure graph reflects new entity
+      cacheService.invalidatePattern('graph_complete*'); // Graph caches: "graph_complete_all", "graph_complete_{viewConfig}"
       
       res.status(201).json(transformed);
     }));
@@ -323,12 +357,14 @@ export function createEntityRouter<T>(config: EntityRouterConfig<T>) {
       );
     }
     
-    // Invalidate cache for this entity
-    await cacheService.invalidateEntity(config.entityName, id);
-    // Also invalidate list caches
-    await cacheService.invalidatePattern(`${config.entityName}:*`);
+    // Invalidate cache for this entity and lists
+    cacheService.invalidatePattern(`${config.entityName}_${id}`);
+    cacheService.invalidatePattern(`${config.entityName}:*`);
+    
+    // Invalidate graph cache to ensure graph reflects deletion
+    cacheService.invalidatePattern('graph_complete*');
     
-    res.status(204).send();
+    res.status(200).json({ success: true });
   }));
   
   // PUT /:id - Update entity (if mapper provided)
@@ -370,34 +406,27 @@ export function createEntityRouter<T>(config: EntityRouterConfig<T>) {
         );
       }
       
-      // Invalidate caches for this entity and related patterns
-      await cacheService.invalidateEntity(config.entityName, req.params.id);
+      // Invalidate caches for this entity
+      cacheService.invalidatePattern(`${config.entityName}_${req.params.id}`);
+      cacheService.invalidatePattern(`${config.entityName}:*`);
+      
+      // Invalidate graph cache to ensure graph reflects updates
+      cacheService.invalidatePattern('graph_complete*');
       
       // If we have inverse relations, invalidate those entity types too
       if (config.inverseRelations) {
-        const relatedEntities: Array<{ type: string; ids: string[] }> = [];
-        
         for (const relation of config.inverseRelations) {
           // Extract entity name from the target database ID pattern
           const targetEntityName = relation.targetDatabaseId.includes('element') ? 'elements' :
                                    relation.targetDatabaseId.includes('puzzle') ? 'puzzles' :
                                    relation.targetDatabaseId.includes('character') ? 'characters' : 
-                                   'unknown';
+                                   'timeline';
           
-          // Collect related IDs for batch invalidation
-          const relatedIds = transformed[relation.sourceField as keyof typeof transformed] as string[] || [];
-          if (relatedIds.length > 0) {
-            relatedEntities.push({ type: targetEntityName, ids: relatedIds });
-          }
-        }
-        
-        // Batch invalidate related entities
-        if (relatedEntities.length > 0) {
-          await cacheService.invalidateRelated(config.entityName, req.params.id, relatedEntities);
+          // Invalidate the target entity type caches
+          cacheService.invalidatePattern(`${targetEntityName}:*`);
         }
       }
       
-      res.setHeader('X-Cache-Version', cacheService.getVersion());
       res.json(transformed);
     }));
   }
diff --git a/server/routes/notion/timeline.ts b/server/routes/notion/timeline.ts
index 527d41c..e5bbb89 100644
--- a/server/routes/notion/timeline.ts
+++ b/server/routes/notion/timeline.ts
@@ -26,7 +26,7 @@
  * - memoryEvidenceIds: Related evidence/memories
  */
 
-import { createEntityRouter } from './createEntityRouter.js';
+import { createEntityRouter, type InverseRelation } from './createEntityRouter.js';
 import { transformTimelineEvent } from '../../../src/types/notion/transforms.js';
 import { toNotionTimelineProperties } from '../../services/notionPropertyMappers.js';
 import config from '../../config/index.js';
@@ -37,6 +37,56 @@ import config from '../../config/index.js';
  */
 const TIMELINE_DATABASE_ID = config.notionDatabaseIds.timeline;
 
+/**
+ * Notion database ID for characters collection.
+ * Used for inverse relation updates.
+ * @constant {string}
+ */
+const CHARACTERS_DATABASE_ID = config.notionDatabaseIds.characters;
+
+/**
+ * Notion database ID for elements collection.
+ * Used for inverse relation updates.
+ * @constant {string}
+ */
+const ELEMENTS_DATABASE_ID = config.notionDatabaseIds.elements;
+
+/**
+ * Inverse relation configuration for timeline events.
+ * Defines how timeline updates propagate to related characters and elements.
+ * 
+ * @constant {InverseRelation[]} timelineInverseRelations
+ * 
+ * **Relation Types:**
+ * 1. **charactersInvolvedIds**: Characters involved in this timeline event
+ *    - Updates Character.Events field
+ *    - Many-to-many bidirectional
+ * 
+ * 2. **memoryEvidenceIds**: Elements that are memories/evidence from this event
+ *    - Updates Element.TimelineEvent field
+ *    - Many-to-one bidirectional (many elements can reference one timeline event)
+ * 
+ * **Synchronization:**
+ * When a timeline event's relationships change, the corresponding
+ * character and element records are automatically updated to maintain consistency.
+ */
+const timelineInverseRelations: InverseRelation[] = [
+  {
+    sourceField: 'charactersInvolvedIds',
+    targetDatabaseId: CHARACTERS_DATABASE_ID,
+    targetField: 'Events',
+    relationType: 'many-to-many',
+    bidirectional: true
+  },
+  {
+    sourceField: 'memoryEvidenceIds',
+    targetDatabaseId: ELEMENTS_DATABASE_ID,
+    targetField: 'Timeline Event',
+    relationType: 'many-to-many',  // Many elements can be evidence from many timeline events
+    bidirectional: true
+  }
+];
+
 /**
  * Create Express router for timeline event endpoints.
  * Minimal configuration as timeline events are straightforward.
@@ -47,7 +97,7 @@ const TIMELINE_DATABASE_ID = config.notionDatabaseIds.timeline;
  * - Transform: Converts Notion → App format
  * - ToNotionProps: Converts App → Notion format
  * - No filters: Timeline events are typically shown in chronological order
- * - No inverse relations: Relationships are one-way references
+ * - InverseRelations: Bidirectional sync with Characters and Elements
  * 
  * **Request Flow:**
  * 1. Request hits router endpoint
@@ -69,5 +119,6 @@ export default createEntityRouter({
   databaseId: TIMELINE_DATABASE_ID,
   entityName: 'timeline',
   transform: transformTimelineEvent,
-  toNotionProps: toNotionTimelineProperties
+  toNotionProps: toNotionTimelineProperties,
+  inverseRelations: timelineInverseRelations
 });
\ No newline at end of file
diff --git a/server/services/CacheCoordinator.ts b/server/services/CacheCoordinator.ts
deleted file mode 100644
index a9420e5..0000000
--- a/server/services/CacheCoordinator.ts
+++ /dev/null
@@ -1,479 +0,0 @@
-/**
- * CacheCoordinator Service
- * 
- * Manages cache consistency across frontend and backend boundaries.
- * Provides version-based cache invalidation and cross-boundary synchronization
- * to ensure data consistency when entities are updated.
- * 
- * @module server/services/CacheCoordinator
- * 
- * **Architecture:**
- * - Singleton pattern for global cache coordination
- * - Version management for cache invalidation
- * - Atomic invalidation of related entities
- * - Cross-boundary synchronization via headers
- * - Queue-based invalidation processing
- * 
- * **Features:**
- * - Entity-specific invalidation
- * - Related entity cascade invalidation
- * - Global cache clearing
- * - Version tracking per entity
- * - Invalidation event queue
- * 
- * **Usage:**
- * ```typescript
- * const coordinator = CacheCoordinator.getInstance(cache);
- * await coordinator.invalidateEntity('elements', 'element-123');
- * ```
- */
-
-import NodeCache from 'node-cache';
-import crypto from 'crypto';
-import { log } from '../utils/logger.js';
-
-/**
- * Represents a cache invalidation event.
- * @interface InvalidationEvent
- * 
- * @property {string} type - Type of invalidation (entity, related, all)
- * @property {string} entityType - Entity type being invalidated
- * @property {string} [entityId] - Specific entity ID
- * @property {string[]} [relatedIds] - Related entity IDs to invalidate
- * @property {number} timestamp - When invalidation occurred
- * @property {string} version - New version after invalidation
- */
-interface InvalidationEvent {
-  type: 'entity' | 'related' | 'all';
-  entityType: string;
-  entityId?: string;
-  relatedIds?: string[];
-  timestamp: number;
-  version: string;
-}
-
-/**
- * Cache metadata for version tracking.
- * @interface CacheMetadata
- * 
- * @property {string} version - Global cache version
- * @property {number} lastInvalidation - Timestamp of last invalidation
- * @property {number} invalidationCount - Total invalidations performed
- * @property {Map} entityVersions - Per-entity version tracking
- */
-interface CacheMetadata {
-  version: string;
-  lastInvalidation: number;
-  invalidationCount: number;
-  entityVersions: Map<string, string>;
-}
-
-/**
- * CacheCoordinator class - Singleton cache management service.
- * Coordinates cache invalidation across the application boundaries.
- * 
- * @class CacheCoordinator
- * @singleton
- * 
- * **Responsibilities:**
- * - Track cache versions globally and per-entity
- * - Process invalidation events atomically
- * - Maintain invalidation history
- * - Provide version headers for cross-boundary sync
- */
-export class CacheCoordinator {
-  private static instance: CacheCoordinator;
-  private version: string;
-  private metadata: CacheMetadata;
-  private invalidationQueue: InvalidationEvent[] = [];
-  private cache: NodeCache;
-
-  private constructor(cache: NodeCache) {
-    this.cache = cache;
-    this.version = this.generateVersion();
-    this.metadata = {
-      version: this.version,
-      lastInvalidation: Date.now(),
-      invalidationCount: 0,
-      entityVersions: new Map()
-    };
-  }
-
-  /**
-   * Get singleton instance of CacheCoordinator.
-   * Creates instance on first call, returns existing instance on subsequent calls.
-   * 
-   * @static
-   * @param {NodeCache} cache - NodeCache instance to coordinate
-   * @returns {CacheCoordinator} Singleton instance
-   * 
-   * @example
-   * const coordinator = CacheCoordinator.getInstance(cache);
-   */
-  static getInstance(cache: NodeCache): CacheCoordinator {
-    if (!CacheCoordinator.instance) {
-      CacheCoordinator.instance = new CacheCoordinator(cache);
-    }
-    return CacheCoordinator.instance;
-  }
-
-  /**
-   * Generate a unique version identifier.
-   * Uses SHA256 hash of timestamp and random value.
-   * 
-   * @private
-   * @returns {string} 12-character version hash
-   */
-  private generateVersion(): string {
-    return crypto
-      .createHash('sha256')
-      .update(`${Date.now()}-${Math.random()}`)
-      .digest('hex')
-      .substring(0, 12);
-  }
-
-  /**
-   * Invalidate a specific entity and all related caches.
-   * Creates invalidation event and updates version tracking.
-   * 
-   * @async
-   * @param {string} entityType - Type of entity (elements, puzzles, etc.)
-   * @param {string} entityId - Entity ID to invalidate
-   * @returns {Promise<void>}
-   * 
-   * @example
-   * await coordinator.invalidateEntity('elements', 'abc-123');
-   */
-  async invalidateEntity(entityType: string, entityId: string): Promise<void> {
-    log.info('[CacheCoordinator] Invalidating entity', { entityType, entityId });
-    
-    // Create invalidation event
-    const event: InvalidationEvent = {
-      type: 'entity',
-      entityType,
-      entityId,
-      timestamp: Date.now(),
-      version: this.generateVersion()
-    };
-    
-    // Queue the invalidation
-    this.invalidationQueue.push(event);
-    
-    // Process invalidation
-    await this.processInvalidation(event);
-    
-    // Update metadata
-    this.metadata.lastInvalidation = Date.now();
-    this.metadata.invalidationCount++;
-    this.metadata.entityVersions.set(`${entityType}:${entityId}`, event.version);
-    
-    // Update global version
-    this.version = this.generateVersion();
-    this.metadata.version = this.version;
-  }
-
-  /**
-   * Invalidate all related entities based on relationships.
-   * Cascades invalidation to all connected entities.
-   * 
-   * @async
-   * @param {string} entityType - Primary entity type
-   * @param {string} entityId - Primary entity ID
-   * @param {Array} relatedEntities - Related entities to invalidate
-   * @returns {Promise<void>}
-   * 
-   * @example
-   * await coordinator.invalidateRelated('puzzles', 'puzzle-1', [
-   *   { type: 'elements', ids: ['elem-1', 'elem-2'] }
-   * ]);
-   */
-  async invalidateRelated(
-    entityType: string,
-    entityId: string,
-    relatedEntities: Array<{ type: string; ids: string[] }>
-  ): Promise<void> {
-    log.info('[CacheCoordinator] Invalidating related entities', { entityType, entityId, relatedEntities });
-    
-    const relatedIds: string[] = [];
-    
-    for (const related of relatedEntities) {
-      for (const id of related.ids) {
-        relatedIds.push(`${related.type}:${id}`);
-        
-        // Create individual invalidation events
-        const event: InvalidationEvent = {
-          type: 'related',
-          entityType: related.type,
-          entityId: id,
-          timestamp: Date.now(),
-          version: this.generateVersion()
-        };
-        
-        this.invalidationQueue.push(event);
-        await this.processInvalidation(event);
-        
-        // Update entity version
-        this.metadata.entityVersions.set(`${related.type}:${id}`, event.version);
-      }
-    }
-    
-    // Update metadata
-    this.metadata.lastInvalidation = Date.now();
-    this.metadata.invalidationCount += relatedIds.length;
-    
-    // Update global version
-    this.version = this.generateVersion();
-    this.metadata.version = this.version;
-  }
-
-  /**
-   * Process a single invalidation event.
-   * Deletes cache keys matching the invalidation pattern.
-   * 
-   * @private
-   * @async
-   * @param {InvalidationEvent} event - Invalidation event to process
-   * @returns {Promise<void>}
-   * 
-   * **Key Patterns:**
-   * - Collection: `entityType:limit:cursor`
-   * - Single: `entityType_entityId:limit:cursor`
-   */
-  private async processInvalidation(event: InvalidationEvent): Promise<void> {
-    // Clear specific cache keys - must match getCacheKey format
-    const keysToDelete: string[] = [];
-    const allKeys = this.cache.keys();
-    
-    if (event.entityId) {
-      // For specific entity, clear:
-      // 1. Collection keys: entityType:*:* (e.g., "puzzles:20:null")
-      // 2. Single entity keys: entityType_entityId:*:* (e.g., "puzzles_123:20:null")
-      const entityPattern = new RegExp(`^${event.entityType}:`);
-      const singleEntityPattern = new RegExp(`^${event.entityType}_${event.entityId}:`);
-      
-      for (const key of allKeys) {
-        if (entityPattern.test(key) || singleEntityPattern.test(key)) {
-          keysToDelete.push(key);
-        }
-      }
-    } else {
-      // All entities of type - clear all keys starting with entityType:
-      const entityPattern = new RegExp(`^${event.entityType}:`);
-      keysToDelete.push(...allKeys.filter(key => entityPattern.test(key)));
-    }
-    
-    // Delete from cache
-    for (const key of keysToDelete) {
-      this.cache.del(key);
-      log.debug('[CacheCoordinator] Deleted cache key', { key });
-    }
-  }
-
-  /**
-   * Get current global cache version.
-   * Used for cross-boundary cache synchronization.
-   * 
-   * @returns {string} Current cache version
-   */
-  getVersion(): string {
-    return this.version;
-  }
-
-  /**
-   * Get entity-specific version.
-   * Returns version for a specific entity if it has been invalidated.
-   * 
-   * @param {string} entityType - Entity type
-   * @param {string} entityId - Entity ID
-   * @returns {string | undefined} Entity version or undefined
-   */
-  getEntityVersion(entityType: string, entityId: string): string | undefined {
-    return this.metadata.entityVersions.get(`${entityType}:${entityId}`);
-  }
-
-  /**
-   * Validate client version against current version.
-   * Checks if client cache is still valid.
-   * 
-   * @param {string} clientVersion - Version from client
-   * @returns {boolean} True if versions match
-   */
-  validateVersion(clientVersion: string): boolean {
-    return clientVersion === this.version;
-  }
-
-  /**
-   * Validate entity-specific version.
-   * Checks if client's entity cache is still valid.
-   * 
-   * @param {string} entityType - Entity type
-   * @param {string} entityId - Entity ID
-   * @param {string} clientVersion - Client's entity version
-   * @returns {boolean} True if versions match
-   */
-  validateEntityVersion(
-    entityType: string,
-    entityId: string,
-    clientVersion: string
-  ): boolean {
-    const currentVersion = this.getEntityVersion(entityType, entityId);
-    return currentVersion === clientVersion;
-  }
-
-  /**
-   * Get cache metadata for monitoring.
-   * Returns copy of metadata for inspection without mutation.
-   * 
-   * @returns {CacheMetadata} Cache metadata copy
-   */
-  getMetadata(): CacheMetadata {
-    return {
-      ...this.metadata,
-      entityVersions: new Map(this.metadata.entityVersions)
-    };
-  }
-
-  /**
-   * Get invalidation history.
-   * Returns recent invalidation events for debugging.
-   * 
-   * @param {number} [limit=100] - Maximum events to return
-   * @returns {InvalidationEvent[]} Recent invalidation events
-   */
-  getInvalidationHistory(limit: number = 100): InvalidationEvent[] {
-    return this.invalidationQueue.slice(-limit);
-  }
-
-  /**
-   * Clear all caches and reset version.
-   * Nuclear option - invalidates everything.
-   * 
-   * @async
-   * @returns {Promise<void>}
-   * 
-   * **Effects:**
-   * - Flushes all cache entries
-   * - Resets version tracking
-   * - Clears invalidation history
-   * - Generates new global version
-   */
-  async clearAll(): Promise<void> {
-    log.info('[CacheCoordinator] Clearing all caches');
-    
-    // Clear node-cache
-    this.cache.flushAll();
-    
-    // Reset metadata
-    this.version = this.generateVersion();
-    this.metadata = {
-      version: this.version,
-      lastInvalidation: Date.now(),
-      invalidationCount: 0,
-      entityVersions: new Map()
-    };
-    
-    // Clear invalidation queue
-    this.invalidationQueue = [];
-    
-    // Create clear-all event
-    const event: InvalidationEvent = {
-      type: 'all',
-      entityType: 'all',
-      timestamp: Date.now(),
-      version: this.version
-    };
-    
-    this.invalidationQueue.push(event);
-  }
-
-  /**
-   * Invalidate cache for specific filters.
-   * Clears cached results for filtered queries.
-   * 
-   * @async
-   * @param {string} entityType - Entity type
-   * @param {Record<string, any>} filters - Filter parameters
-   * @returns {Promise<void>}
-   * 
-   * @example
-   * await coordinator.invalidateFilters('puzzles', { act: 'Act1' });
-   */
-  async invalidateFilters(entityType: string, filters: Record<string, any>): Promise<void> {
-    log.info('[CacheCoordinator] Invalidating filtered cache', { entityType, filters });
-    
-    // Build filter key
-    const filterKey = Object.entries(filters)
-      .sort(([a], [b]) => a.localeCompare(b))
-      .map(([key, value]) => `${key}:${value}`)
-      .join(',');
-    
-    const cacheKey = `${entityType}:filter:${filterKey}`;
-    
-    // Delete from cache
-    this.cache.del(cacheKey);
-    
-    // Update version
-    this.version = this.generateVersion();
-    this.metadata.version = this.version;
-    this.metadata.lastInvalidation = Date.now();
-    this.metadata.invalidationCount++;
-  }
-
-  /**
-   * Batch invalidation for performance.
-   * Invalidates multiple entities in a single operation.
-   * 
-   * @async
-   * @param {Array} invalidations - Array of entities to invalidate
-   * @returns {Promise<void>}
-   * 
-   * **Performance:**
-   * - More efficient than individual invalidations
-   * - Single version update after all invalidations
-   * - Reduces overhead for bulk operations
-   * 
-   * @example
-   * await coordinator.batchInvalidate([
-   *   { entityType: 'elements', entityId: 'elem-1' },
-   *   { entityType: 'elements', entityId: 'elem-2' },
-   *   { entityType: 'puzzles', entityId: 'puzzle-1' }
-   * ]);
-   */
-  async batchInvalidate(
-    invalidations: Array<{ entityType: string; entityId: string }>
-  ): Promise<void> {
-    log.info('[CacheCoordinator] Batch invalidating entities', { count: invalidations.length });
-    
-    const startTime = Date.now();
-    
-    for (const { entityType, entityId } of invalidations) {
-      // Create invalidation event
-      const event: InvalidationEvent = {
-        type: 'entity',
-        entityType,
-        entityId,
-        timestamp: Date.now(),
-        version: this.generateVersion()
-      };
-      
-      this.invalidationQueue.push(event);
-      await this.processInvalidation(event);
-      
-      // Update entity version
-      this.metadata.entityVersions.set(`${entityType}:${entityId}`, event.version);
-    }
-    
-    // Update metadata
-    this.metadata.lastInvalidation = Date.now();
-    this.metadata.invalidationCount += invalidations.length;
-    
-    // Update global version
-    this.version = this.generateVersion();
-    this.metadata.version = this.version;
-    
-    const duration = Date.now() - startTime;
-    log.info('[CacheCoordinator] Batch invalidation completed', { durationMs: duration });
-  }
-}
-
-export default CacheCoordinator;
\ No newline at end of file
diff --git a/server/services/cache.ts b/server/services/cache.ts
index 8c837c3..8e15b09 100644
--- a/server/services/cache.ts
+++ b/server/services/cache.ts
@@ -1,5 +1,4 @@
 import NodeCache from 'node-cache';
-import { CacheCoordinator } from './CacheCoordinator';
 import { log } from '../utils/logger.js';
 
 export interface CacheStats {
@@ -30,7 +29,6 @@ export interface CacheStats {
  */
 export class CacheService {
   private cache: NodeCache;
-  private coordinator: CacheCoordinator;
   private readonly DEFAULT_TTL = 300; // 5 minutes
   private readonly MAX_KEYS = 1000;
   private readonly CHECK_PERIOD = 600; // 10 minutes
@@ -43,7 +41,6 @@ export class CacheService {
       deleteOnExpire: true,
       useClones: false, // Performance optimization
     });
-    this.coordinator = CacheCoordinator.getInstance(this.cache);
   }
 
   /**
@@ -184,60 +181,6 @@ export class CacheService {
     return deletedCount;
   }
 
-  /**
-   * Get cache version for validation
-   */
-  getVersion(): string {
-    return this.coordinator.getVersion();
-  }
-
-  /**
-   * Validate client cache version
-   */
-  validateVersion(clientVersion: string): boolean {
-    return this.coordinator.validateVersion(clientVersion);
-  }
-
-  /**
-   * Invalidate entity and related caches
-   */
-  async invalidateEntity(entityType: string, entityId: string): Promise<void> {
-    await this.coordinator.invalidateEntity(entityType, entityId);
-  }
-
-  /**
-   * Invalidate related entities
-   */
-  async invalidateRelated(
-    entityType: string,
-    entityId: string,
-    relatedEntities: Array<{ type: string; ids: string[] }>
-  ): Promise<void> {
-    await this.coordinator.invalidateRelated(entityType, entityId, relatedEntities);
-  }
-
-  /**
-   * Get cache metadata for monitoring
-   */
-  getCacheMetadata() {
-    return this.coordinator.getMetadata();
-  }
-
-  /**
-   * Batch invalidate multiple entities
-   */
-  async batchInvalidate(
-    invalidations: Array<{ entityType: string; entityId: string }>
-  ): Promise<void> {
-    await this.coordinator.batchInvalidate(invalidations);
-  }
-
-  /**
-   * Get entity-specific version
-   */
-  getEntityVersion(entityType: string, entityId: string): string | undefined {
-    return this.coordinator.getEntityVersion(entityType, entityId);
-  }
 }
 
 // Singleton instance for application-wide caching
diff --git a/server/services/notionPropertyMappers.ts b/server/services/notionPropertyMappers.ts
index f4f9e05..e6a16c6 100644
--- a/server/services/notionPropertyMappers.ts
+++ b/server/services/notionPropertyMappers.ts
@@ -44,6 +44,43 @@ import {
   TimelineProperties
 } from '../../src/types/notion/schema-mapping.js';
 
+/**
+ * Explicit field-to-property mapping for direct lookup
+ * Eliminates need for "dummy object" pattern in createEntityRouter
+ */
+export const FIELD_TO_NOTION_PROPERTY = {
+  puzzle: {
+    puzzleElementIds: PuzzleProperties.PUZZLE_ELEMENTS,
+    rewardIds: PuzzleProperties.REWARDS,
+    lockedItemId: PuzzleProperties.LOCKED_ITEM,
+    parentItemId: PuzzleProperties.PARENT_ITEM,
+    subPuzzleIds: PuzzleProperties.SUB_PUZZLES,
+    // Note: characterIds doesn't exist in Notion schema
+    // The relationship is stored on characters as characterPuzzleIds
+    // This mapping is here for completeness but should not be used
+    characterIds: 'Characters' // This field doesn't actually exist in Notion
+  },
+  element: {
+    ownerId: ElementProperties.OWNER,
+    containerId: ElementProperties.CONTAINER,
+    contentIds: ElementProperties.CONTENTS,
+    timelineEventId: ElementProperties.TIMELINE_EVENT,
+    containerPuzzleId: ElementProperties.CONTAINER_PUZZLE,
+    requiredForPuzzleIds: ElementProperties.REQUIRED_FOR_PUZZLE,
+    rewardedByPuzzleIds: ElementProperties.REWARDED_BY_PUZZLE
+  },
+  character: {
+    ownedElementIds: CharacterProperties.OWNED_ELEMENTS,
+    associatedElementIds: CharacterProperties.ASSOCIATED_ELEMENTS,
+    characterPuzzleIds: CharacterProperties.CHARACTER_PUZZLES,
+    eventIds: CharacterProperties.EVENTS
+  },
+  timeline: {
+    charactersInvolvedIds: TimelineProperties.CHARACTERS_INVOLVED,
+    memoryEvidenceIds: TimelineProperties.MEMORY_EVIDENCE
+  }
+} as const;
+
 /**
  * Convert plain text to Notion title property format.
  * Title properties are used for primary identifiers (Name fields).
diff --git a/server/services/relationshipSynthesizer.ts b/server/services/relationshipSynthesizer.ts
index 40786d1..c9a4058 100644
--- a/server/services/relationshipSynthesizer.ts
+++ b/server/services/relationshipSynthesizer.ts
@@ -1,14 +1,16 @@
-import type { Element, Puzzle } from '../../src/types/notion/app.js';
+import type { Character, Element, Puzzle, TimelineEvent } from '../../src/types/notion/app.js';
 
 /**
- * Synthesizes bidirectional relationships between puzzles and elements.
+ * Synthesizes bidirectional relationships between puzzles, elements, timeline events, and characters.
  * Since Notion doesn't maintain bidirectional relations automatically,
  * we need to compute the reverse relationships from the forward ones.
  */
 export function synthesizeBidirectionalRelationships(
   elements: Element[],
-  puzzles: Puzzle[]
-): { elements: Element[], puzzles: Puzzle[] } {
+  puzzles: Puzzle[],
+  timeline: TimelineEvent[] = [],
+  characters: Character[] = []
+): { elements: Element[], puzzles: Puzzle[], timeline: TimelineEvent[], characters: Character[] } {
   // Create a map for quick lookup
   const elementMap = new Map(elements.map(e => [e.id, e]));
   const puzzleMap = new Map(puzzles.map(p => [p.id, p]));
@@ -16,6 +18,8 @@ export function synthesizeBidirectionalRelationships(
   // Clone arrays to avoid mutating originals
   const synthesizedElements = elements.map(e => ({ ...e }));
   const synthesizedPuzzles = puzzles.map(p => ({ ...p }));
+  const synthesizedTimeline = timeline.map(t => ({ ...t }));
+  const synthesizedCharacters = characters.map(c => ({ ...c }));
   
   // Build reverse relationships from puzzles to elements
   for (const puzzle of synthesizedPuzzles) {
@@ -145,8 +149,94 @@ export function synthesizeBidirectionalRelationships(
     }
   }
   
+  // Synthesize puzzle -> timeline relationships
+  for (const puzzle of synthesizedPuzzles) {
+    // If this puzzle has story reveals (timeline events), create inverse relationship
+    if (puzzle.storyReveals && puzzle.storyReveals.length > 0) {
+      for (const timelineId of puzzle.storyReveals) {
+        const timelineEvent = synthesizedTimeline.find(t => t.id === timelineId);
+        if (timelineEvent) {
+          // Ensure the array exists
+          if (!timelineEvent.associatedPuzzles) {
+            timelineEvent.associatedPuzzles = [];
+          }
+          // Add puzzle ID if not already present
+          if (!timelineEvent.associatedPuzzles.includes(puzzle.id)) {
+            timelineEvent.associatedPuzzles.push(puzzle.id);
+          }
+        }
+      }
+    }
+  }
+  
+  // Synthesize Timeline -> Character bidirectional relationships
+  for (const timelineEvent of synthesizedTimeline) {
+    // Process characters involved
+    if (timelineEvent.charactersInvolvedIds?.length) {
+      for (const characterId of timelineEvent.charactersInvolvedIds) {
+        const character = synthesizedCharacters.find(c => c.id === characterId);
+        if (character) {
+          if (!character.eventIds) {
+            character.eventIds = [];
+          }
+          if (!character.eventIds.includes(timelineEvent.id)) {
+            character.eventIds.push(timelineEvent.id);
+          }
+        }
+      }
+    }
+    
+    // Process memory/evidence elements
+    if (timelineEvent.memoryEvidenceIds?.length) {
+      for (const elementId of timelineEvent.memoryEvidenceIds) {
+        const element = synthesizedElements.find(e => e.id === elementId);
+        if (element) {
+          // Element.timelineEventId is single value, not array
+          // Only set if not already set (preserve existing)
+          if (!element.timelineEventId) {
+            element.timelineEventId = timelineEvent.id;
+          }
+        }
+      }
+    }
+  }
+  
+  // Also ensure reverse: Character -> Timeline
+  for (const character of synthesizedCharacters) {
+    if (character.eventIds?.length) {
+      for (const eventId of character.eventIds) {
+        const timeline = synthesizedTimeline.find(t => t.id === eventId);
+        if (timeline) {
+          if (!timeline.charactersInvolvedIds) {
+            timeline.charactersInvolvedIds = [];
+          }
+          if (!timeline.charactersInvolvedIds.includes(character.id)) {
+            timeline.charactersInvolvedIds.push(character.id);
+          }
+        }
+      }
+    }
+  }
+  
+  // And Element -> Timeline
+  for (const element of synthesizedElements) {
+    if (element.timelineEventId) {
+      const timeline = synthesizedTimeline.find(t => t.id === element.timelineEventId);
+      if (timeline) {
+        if (!timeline.memoryEvidenceIds) {
+          timeline.memoryEvidenceIds = [];
+        }
+        if (!timeline.memoryEvidenceIds.includes(element.id)) {
+          timeline.memoryEvidenceIds.push(element.id);
+        }
+      }
+    }
+  }
+  
   return {
     elements: synthesizedElements,
-    puzzles: synthesizedPuzzles
+    puzzles: synthesizedPuzzles,
+    timeline: synthesizedTimeline,
+    characters: synthesizedCharacters  // Now returning modified characters too
   };
 }
\ No newline at end of file
diff --git a/src/App.tsx b/src/App.tsx
index 281c1fa..38250b1 100644
--- a/src/App.tsx
+++ b/src/App.tsx
@@ -2,7 +2,6 @@ import { BrowserRouter } from 'react-router-dom';
 import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
 import { Toaster } from 'react-hot-toast';
 import AppRouter from './router/AppRouter';
-import { cacheVersionManager } from '@/lib/cache/CacheVersionManager';
 import { ViewContextProvider } from '@/contexts/ViewContext';
 import { CreatePanelPortal } from '@/components/CreatePanelPortal';
 // GraphContextProvider removed in Phase 3 cleanup
@@ -20,8 +19,6 @@ const queryClient = new QueryClient({
   },
 });
 
-// Initialize cache version manager with query client
-cacheVersionManager.initialize(queryClient);
 
 function App() {
   return (
diff --git a/src/components/CreatePanelPortal.tsx b/src/components/CreatePanelPortal.tsx
index 99fdf26..4d59fa5 100644
--- a/src/components/CreatePanelPortal.tsx
+++ b/src/components/CreatePanelPortal.tsx
@@ -92,7 +92,7 @@ export function CreatePanelPortal() {
                     console.warn(`Failed to find node ${graphNodeId} after ${maxRetries} attempts`);
                     // Still set selection state even if focus fails
                     useFilterStore.getState().setSelectedNode(graphNodeId);
-                    useFilterStore.getState().setFocusedNode(graphNodeId);
+                    useFilterStore.getState().setSelectedNode(graphNodeId);
                     return;
                   }
                   
@@ -111,7 +111,7 @@ export function CreatePanelPortal() {
                     // For focus, we need to verify the node exists in the graph
                     // We'll check by trying to focus and seeing if it succeeds
                     // The viewport manager will handle the actual focusing
-                    currentState.setFocusedNode(graphNodeId);
+                    currentState.setSelectedNode(graphNodeId);
                     
                     // If this is first attempt, schedule a verification check
                     if (retries === 0) {
diff --git a/src/components/DetailPanel.tsx b/src/components/DetailPanel.tsx
index da7161b..1613ed9 100644
--- a/src/components/DetailPanel.tsx
+++ b/src/components/DetailPanel.tsx
@@ -776,7 +776,11 @@ export const DetailPanel: React.FC<DetailPanelProps> = ({
                   {fieldsByCategory.relations.map((field) => (
                     <FieldEditor
                       key={field.key}
-                      field={field}
+                      field={{
+                        ...field,
+                        currentEntityId: entity?.id,
+                        currentEntityType: entityType
+                      }}
                       value={formData[field.key as keyof Entity]}
                       onChange={(value) => handleFieldChange(field.key, value)}
                       error={validationErrors[field.key]}
diff --git a/src/components/filters/EntityTypeToggle.tsx b/src/components/filters/EntityTypeToggle.tsx
index bc8a74e..57fef77 100644
--- a/src/components/filters/EntityTypeToggle.tsx
+++ b/src/components/filters/EntityTypeToggle.tsx
@@ -37,7 +37,7 @@ const EntityTypeToggle = memo(() => {
   
   const entityConfig = [
     {
-      key: 'characters' as const,
+      key: 'character' as const,
       label: 'Characters',
       icon: Users,
       color: 'text-green-600',
@@ -45,7 +45,7 @@ const EntityTypeToggle = memo(() => {
       borderColor: 'border-green-200'
     },
     {
-      key: 'puzzles' as const,
+      key: 'puzzle' as const,
       label: 'Puzzles',
       icon: Puzzle,
       color: 'text-amber-600',
@@ -53,7 +53,7 @@ const EntityTypeToggle = memo(() => {
       borderColor: 'border-amber-200'
     },
     {
-      key: 'elements' as const,
+      key: 'element' as const,
       label: 'Elements',
       icon: Package,
       color: 'text-purple-600',
diff --git a/src/components/graph/FilterStatusBar.tsx b/src/components/graph/FilterStatusBar.tsx
index 214cdcf..5ce115b 100644
--- a/src/components/graph/FilterStatusBar.tsx
+++ b/src/components/graph/FilterStatusBar.tsx
@@ -1,79 +1,50 @@
 /**
  * FilterStatusBar Component
  * Persistent UI feedback about filtering state
- * Shows total/visible nodes, filter mode, and connection depth
+ * Shows total/visible nodes and connection depth
  */
 
 import { memo } from 'react';
 import { Card } from '@/components/ui/card';
 import { Badge } from '@/components/ui/badge';
-import { Info, Filter, Target, Network } from 'lucide-react';
-import { cn } from '@/lib/utils';
+import { Info, Target, Network } from 'lucide-react';
 
 interface FilterStatusBarProps {
   totalNodes: number;
   visibleNodes: number;
-  filterMode: 'pure' | 'connected' | 'focused';
   connectionDepth: number;
-  focusedNode?: { id: string; name: string } | null;
+  selectedNode?: { id: string; name: string } | null;
   hasActiveFilters: boolean;
 }
 
 export const FilterStatusBar = memo(function FilterStatusBar({
   totalNodes,
   visibleNodes,
-  filterMode,
   connectionDepth,
-  focusedNode,
+  selectedNode,
   hasActiveFilters
 }: FilterStatusBarProps) {
   // Don't show if no filters are active and all nodes are visible
-  if (!hasActiveFilters && totalNodes === visibleNodes && !focusedNode) {
+  if (!hasActiveFilters && totalNodes === visibleNodes && !selectedNode) {
     return null;
   }
 
-  const getModeIcon = () => {
-    switch (filterMode) {
-      case 'pure':
-        return <Filter className="h-3 w-3" />;
-      case 'focused':
-        return <Target className="h-3 w-3" />;
-      case 'connected':
-        return <Network className="h-3 w-3" />;
-    }
-  };
-
-  const getModeDescription = () => {
-    switch (filterMode) {
-      case 'pure':
-        return 'Showing only filtered nodes';
-      case 'focused':
-        return `Showing ${connectionDepth} ${connectionDepth === 1 ? 'hop' : 'hops'} from ${focusedNode?.name || 'focused node'}`;
-      case 'connected':
-        return `Showing filtered nodes + ${connectionDepth} ${connectionDepth === 1 ? 'hop' : 'hops'}`;
-    }
-  };
-
-  const getModeColor = () => {
-    switch (filterMode) {
-      case 'pure':
-        return 'bg-blue-50 border-blue-200 text-blue-700';
-      case 'focused':
-        return 'bg-yellow-50 border-yellow-200 text-yellow-700';
-      case 'connected':
-        return 'bg-green-50 border-green-200 text-green-700';
+  const getDescription = () => {
+    if (selectedNode) {
+      return `Showing ${connectionDepth} ${connectionDepth === 1 ? 'level' : 'levels'} from ${selectedNode.name}`;
+    } else if (connectionDepth === 0) {
+      return 'Showing only filtered nodes';
+    } else {
+      return `Showing filtered nodes + ${connectionDepth} ${connectionDepth === 1 ? 'level' : 'levels'}`;
     }
   };
 
   return (
-    <Card className={cn(
-      "absolute top-4 left-4 z-20 p-3 shadow-lg border",
-      getModeColor()
-    )}>
+    <Card className="absolute top-4 left-4 z-20 p-3 shadow-lg border bg-white/90 dark:bg-gray-900/90 backdrop-blur-sm">
       <div className="space-y-2">
         {/* Node count */}
-        <div className="flex items-center gap-2 text-sm font-medium">
-          <Info className="h-3 w-3" />
+        <div className="flex items-center gap-2 text-sm font-medium text-gray-900 dark:text-gray-100">
+          <Info className="h-3 w-3 text-gray-500" />
           <span>
             {visibleNodes} / {totalNodes} nodes
           </span>
@@ -84,17 +55,17 @@ export const FilterStatusBar = memo(function FilterStatusBar({
           )}
         </div>
 
-        {/* Filter mode */}
-        <div className="flex items-center gap-2 text-xs">
-          {getModeIcon()}
-          <span>{getModeDescription()}</span>
+        {/* Connection depth description */}
+        <div className="flex items-center gap-2 text-xs text-gray-600 dark:text-gray-400">
+          <Network className="h-3 w-3" />
+          <span>{getDescription()}</span>
         </div>
 
-        {/* Focused node indicator */}
-        {focusedNode && (
-          <div className="flex items-center gap-2 text-xs">
-            <Target className="h-3 w-3 text-yellow-600" />
-            <span className="font-medium">Focus: {focusedNode.name}</span>
+        {/* Selected node indicator */}
+        {selectedNode && (
+          <div className="flex items-center gap-2 text-xs text-gray-600 dark:text-gray-400">
+            <Target className="h-3 w-3 text-blue-600 dark:text-blue-400" />
+            <span className="font-medium">Selected: {selectedNode.name}</span>
           </div>
         )}
       </div>
diff --git a/src/components/graph/GraphView.tsx b/src/components/graph/GraphView.tsx
index a120a15..7041108 100644
--- a/src/components/graph/GraphView.tsx
+++ b/src/components/graph/GraphView.tsx
@@ -50,8 +50,8 @@ import ElementNode from './nodes/ElementNode';
 import TimelineNode from './nodes/TimelineNode';
 import { DetailPanel } from '@/components/DetailPanel';
 import { useViewConfig } from '@/hooks/useViewConfig';
-import { useQueries } from '@tanstack/react-query';
-import { charactersApi, puzzlesApi, elementsApi, timelineApi } from '@/services/api';
+import { useQuery } from '@tanstack/react-query';
+import { graphApi } from '@/services/graphApi';
 import { useViewportManager } from '@/hooks/useGraphState';
 import { useGraphLayout } from '@/hooks/useGraphLayout';
 import { useFilterSelectors } from '@/hooks/useFilterSelectors';
@@ -80,17 +80,15 @@ const nodeTypes = {
 function ViewportController({ 
   searchTerm,
   selectedNodeId,
-  focusedNodeId, 
   connectionDepth,
   nodes 
 }: { 
   searchTerm: string;
   selectedNodeId: string | null;
-  focusedNodeId: string | null;
   connectionDepth: number | null;
   nodes: Node[];
 }) {
-  const viewportControls = useViewportManager(searchTerm, selectedNodeId, focusedNodeId, connectionDepth, nodes);
+  const viewportControls = useViewportManager(searchTerm, selectedNodeId, null, connectionDepth, nodes);
   
   // Initial fit to view on mount or when nodes change significantly
   const hasNodes = nodes.length > 0;
@@ -136,48 +134,59 @@ function GraphViewComponent() {
   // Get view configuration from route
   const { config: viewConfig } = useViewConfig();
   
-  // PHASE 5 FIX: Use parallel queries with useQueries to eliminate waterfall loading
-  // This fetches all entity data simultaneously instead of sequentially
-  const entityQueries = useQueries({
-    queries: [
-      {
-        queryKey: ['characters', 'all'],
-        queryFn: () => charactersApi.listAll(),
-        staleTime: 5 * 60 * 1000,
-      },
-      {
-        queryKey: ['puzzles', 'all'], 
-        queryFn: () => puzzlesApi.listAll(),
-        staleTime: 5 * 60 * 1000,
-      },
-      {
-        queryKey: ['elements', 'all'],
-        queryFn: () => elementsApi.listAll(),
-        staleTime: 5 * 60 * 1000,
-      },
-      {
-        queryKey: ['timeline', 'all'],
-        queryFn: () => timelineApi.listAll(),
-        staleTime: 5 * 60 * 1000,
-      },
-    ],
+  // NEW: Single query to fetch complete graph from server
+  // Server handles all relationship resolution and returns nodes + edges
+  const { 
+    data: graphData, 
+    isLoading: isInitialLoading, 
+    isError: hasAnyError,
+    refetch: refetchAll 
+  } = useQuery({
+    queryKey: ['graph', 'complete', viewConfig?.name],
+    queryFn: () => graphApi.getComplete(viewConfig),
+    staleTime: 5 * 60 * 1000,
+    enabled: !!viewConfig, // Only fetch when we have a view config
   });
-
-  // Extract data from parallel query results
-  const [
-    { data: characters = [] },
-    { data: puzzles = [] },
-    { data: elements = [] },
-    { data: timeline = [] },
-  ] = entityQueries;
   
-  // Check loading and error states across all queries
-  const isInitialLoading = entityQueries.some(q => q.isLoading);
-  const hasAnyError = entityQueries.some(q => q.isError);
-  const refetchAll = () => {
-    // Refetch all queries in parallel
-    entityQueries.forEach(q => q.refetch());
-  };
+  // Extract nodes and edges from graph response
+  const serverNodes = graphData?.nodes || [];
+  const serverEdges = graphData?.edges || [];
+  
+  // Extract entities from nodes for DetailPanel
+  const allEntities = useMemo(() => {
+    const characters: any[] = [];
+    const elements: any[] = [];
+    const puzzles: any[] = [];
+    const timeline: any[] = [];
+    
+    serverNodes.forEach((node: any) => {
+      if (node.data?.entity && node.data?.metadata?.entityType) {
+        switch (node.data.metadata.entityType) {
+          case 'character':
+            characters.push(node.data.entity);
+            break;
+          case 'element':
+            elements.push(node.data.entity);
+            break;
+          case 'puzzle':
+            puzzles.push(node.data.entity);
+            break;
+          case 'timeline':
+            timeline.push(node.data.entity);
+            break;
+        }
+      }
+    });
+    
+    return { characters, elements, puzzles, timeline };
+  }, [serverNodes]);
+  
+  // Log metadata if available
+  useEffect(() => {
+    if (graphData?.metadata?.missingEntities?.length) {
+      console.warn('[GraphView] Missing entities detected:', graphData.metadata.missingEntities);
+    }
+  }, [graphData?.metadata]);
   
   // Use consolidated filter selector for better performance (1 subscription vs 14+)
   const filters = useFilterSelectors();
@@ -186,12 +195,8 @@ function GraphViewComponent() {
   const {
     searchTerm,
     selectedNodeId,
-    focusedNodeId,
     setSelectedNode,
-    setFocusedNode,
     connectionDepth,
-    filterMode,
-    focusRespectFilters,
     entityVisibility,
     characterSelectedTiers,
     characterType,
@@ -216,20 +221,16 @@ function GraphViewComponent() {
 
   /**
    * Use the new consolidated graph layout hook to calculate everything in one go.
-   * This eliminates the 11-stage deferred rendering pipeline and visual desync issues.
+   * Now using server-provided nodes and edges!
    */
   const { layoutedNodes, filteredEdges, totalUniverseNodes } = useGraphLayout({
-    characters,
-    elements,
-    puzzles,
-    timeline,
+    nodes: serverNodes,
+    edges: serverEdges,
     viewConfig,
     // Individual filter values to avoid object recreation
     searchTerm,
-    focusedNodeId,
+    selectedNodeId,
     connectionDepth,
-    filterMode,
-    focusRespectFilters,
     entityVisibility,
     // Character filters as primitives
     characterType,
@@ -273,36 +274,26 @@ function GraphViewComponent() {
 
   // Click handlers for node interaction
   const onNodeClick = (nodeId: string) => {
-    // Always open detail panel for the clicked node
+    // Open detail panel for the clicked node
     setSelectedNode(nodeId);
-    
-    // Toggle focused node for depth filtering
-    if (focusedNodeId === nodeId) {
-      // Clicking the same focused node again unfocuses it
-      setFocusedNode(null);
-    } else {
-      // Set as focused node for depth filtering
-      setFocusedNode(nodeId);
-    }
   };
   
   const onEdgeClick = () => {
     // Edge click handler - currently no action needed
   };
 
-  // Handle detail panel close - only clears selection, not focus
+  // Handle detail panel close - clears selection
   const handleDetailPanelClose = () => {
     setSelectedNode(null);
-    // Keep focusedNodeId - user might want to maintain the filtered view
   };
 
-  // Get focused node details for status bar
-  const focusedNodeData = useMemo(() => {
-    if (!focusedNodeId) return null;
-    const node = layoutedNodes.find(n => n.id === focusedNodeId);
+  // Get selected node details for status bar
+  const selectedNodeData = useMemo(() => {
+    if (!selectedNodeId) return null;
+    const node = layoutedNodes.find(n => n.id === selectedNodeId);
     if (!node) return null;
     return { id: node.id, name: node.data.label };
-  }, [focusedNodeId, layoutedNodes]);
+  }, [selectedNodeId, layoutedNodes]);
 
   // hasActiveFilters is now part of the filters object
 
@@ -324,7 +315,7 @@ function GraphViewComponent() {
         <div className="text-center">
           <p className="text-red-500 mb-4">Error loading graph data</p>
           <button 
-            onClick={refetchAll}
+            onClick={() => refetchAll()}
             className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
           >
             Retry
@@ -341,9 +332,8 @@ function GraphViewComponent() {
         <FilterStatusBar
           totalNodes={totalUniverseNodes}
           visibleNodes={layoutedNodes.length}
-          filterMode={filterMode}
           connectionDepth={connectionDepth ?? 0}
-          focusedNode={focusedNodeData}
+          selectedNode={selectedNodeData}
           hasActiveFilters={hasActiveFilters()}
         />
         
@@ -359,7 +349,6 @@ function GraphViewComponent() {
           <ViewportController 
             searchTerm={searchTerm}
             selectedNodeId={selectedNodeId}
-            focusedNodeId={focusedNodeId}
             connectionDepth={connectionDepth}
             nodes={reactFlowNodes}
           />
@@ -409,12 +398,7 @@ function GraphViewComponent() {
           entity={selectedEntity.entity}
           entityType={selectedEntity.entityType}
           onClose={handleDetailPanelClose}
-          allEntities={{
-            characters,
-            elements,
-            puzzles,
-            timeline
-          }}
+          allEntities={allEntities}
         />
       )}
     </div>
diff --git a/src/components/sidebar/DepthSlider.tsx b/src/components/sidebar/DepthSlider.tsx
index e05d24f..07eb8f6 100644
--- a/src/components/sidebar/DepthSlider.tsx
+++ b/src/components/sidebar/DepthSlider.tsx
@@ -1,57 +1,41 @@
 /**
  * DepthSlider Component
- * Enhanced connection depth slider with mode indication and tick marks
+ * Connection depth slider with tick marks and descriptions
  */
 
 import { useFilterStore } from '@/stores/filterStore';
 import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
 import { Label } from '@/components/ui/label';
-import { Badge } from '@/components/ui/badge';
 import { Info } from 'lucide-react';
 import { cn } from '@/lib/utils';
 
 export function DepthSlider() {
   const connectionDepth = useFilterStore(state => state.connectionDepth);
   const setConnectionDepth = useFilterStore(state => state.setConnectionDepth);
-  const filterMode = useFilterStore(state => state.filterMode);
-  const focusedNodeId = useFilterStore(state => state.focusedNodeId);
+  const selectedNodeId = useFilterStore(state => state.selectedNodeId);
 
-  const getModeDescription = () => {
-    if (focusedNodeId) {
-      return `Showing ${connectionDepth} ${connectionDepth === 1 ? 'level' : 'levels'} from focused node`;
+  const getDescription = () => {
+    if (selectedNodeId) {
+      return `Showing ${connectionDepth} ${connectionDepth === 1 ? 'level' : 'levels'} from selected node`;
     } else if (connectionDepth === 0) {
-      return 'Showing only filtered nodes (no connections)';
+      return 'Showing only filtered nodes';
     } else {
       return `Showing filtered nodes + ${connectionDepth} ${connectionDepth === 1 ? 'level' : 'levels'} of connections`;
     }
   };
 
-  const getModeBadge = () => {
-    switch (filterMode) {
-      case 'pure':
-        return <Badge variant="secondary" className="bg-blue-100 text-blue-700">Pure Filter</Badge>;
-      case 'focused':
-        return <Badge variant="secondary" className="bg-yellow-100 text-yellow-700">Focus Mode</Badge>;
-      case 'connected':
-        return <Badge variant="secondary" className="bg-green-100 text-green-700">Connected</Badge>;
-    }
-  };
-
   const depthLabels = ['None', 'Direct', '2 levels', '3 levels', '4 levels', '5 levels'];
 
   return (
     <Card>
       <CardHeader>
-        <div className="flex items-center justify-between">
-          <CardTitle>Connection Depth</CardTitle>
-          {getModeBadge()}
-        </div>
+        <CardTitle>Connection Depth</CardTitle>
       </CardHeader>
       <CardContent className="space-y-4">
-        {/* Mode description */}
+        {/* Description */}
         <div className="flex items-start gap-2 text-sm text-muted-foreground">
           <Info className="h-4 w-4 mt-0.5 flex-shrink-0" />
-          <span>{getModeDescription()}</span>
+          <span>{getDescription()}</span>
         </div>
 
         {/* Slider with value */}
@@ -120,10 +104,10 @@ export function DepthSlider() {
           </div>
         </div>
 
-        {/* Tips based on mode */}
-        {focusedNodeId && (
-          <div className="p-2 bg-yellow-50 border border-yellow-200 rounded-md text-xs">
-            <strong>Focus Mode Active:</strong> Showing connections from the focused node only. Clear focus to see all filtered nodes.
+        {/* Tips based on selection */}
+        {selectedNodeId && (
+          <div className="p-2 bg-blue-50 border border-blue-200 rounded-md text-xs">
+            <strong>Node Selected:</strong> Showing connections from the selected node only. Deselect to see all filtered nodes.
           </div>
         )}
       </CardContent>
diff --git a/src/hooks/graph/useFilteredEntities.ts b/src/hooks/graph/useFilteredEntities.ts
deleted file mode 100644
index 45f99a9..0000000
--- a/src/hooks/graph/useFilteredEntities.ts
+++ /dev/null
@@ -1,135 +0,0 @@
-/**
- * useFilteredEntities Hook
- * 
- * Handles entity filtering with memoized selectors.
- * Part of the decomposed useGraphLayout architecture.
- * 
- * @module hooks/graph/useFilteredEntities
- * 
- * **Purpose:**
- * Extract node creation and filtering logic from monolithic useGraphLayout.
- * Creates filtered nodes based on entity visibility and filter criteria.
- * 
- * **Performance:**
- * - Memoized to prevent unnecessary recalculation
- * - Only recalculates when entities or filters change
- * - Reduces dependency count from 25 to ~10
- */
-
-import { useMemo } from 'react';
-import { createAllNodes } from '@/lib/graph/nodeCreators';
-import type { GraphNode } from '@/lib/graph/types';
-import type { Character, Puzzle, TimelineEvent, Element } from '@/types/notion/app';
-import type { ViewConfig } from '@/lib/viewConfigs';
-
-interface UseFilteredEntitiesParams {
-  // Entity data
-  characters: Character[];
-  elements: Element[];
-  puzzles: Puzzle[];
-  timeline: TimelineEvent[];
-  
-  // View configuration
-  viewConfig: ViewConfig;
-  
-  // Filter criteria
-  searchTerm: string;
-  entityVisibility: {
-    characters: boolean;
-    elements: boolean;
-    puzzles: boolean;
-    timeline: boolean;
-  };
-  
-  // Character filters
-  characterType: string;
-  characterSelectedTiers: Set<string>;
-  
-  // Puzzle filters
-  puzzleSelectedActs: Set<string>;
-  
-  // Element filters
-  elementBasicTypes: Set<string>;
-  elementStatus: Set<string>;
-}
-
-/**
- * Hook to create filtered nodes from entities.
- * Encapsulates the node creation logic from useGraphLayout.
- * 
- * @param params - Entity data and filter criteria
- * @returns Filtered nodes ready for relationship processing
- * 
- * @example
- * ```typescript
- * const filteredNodes = useFilteredEntities({
- *   characters,
- *   elements,
- *   puzzles,
- *   timeline,
- *   viewConfig,
- *   searchTerm,
- *   entityVisibility,
- *   // ... filter criteria
- * });
- * ```
- */
-export function useFilteredEntities({
-  characters,
-  elements,
-  puzzles,
-  timeline,
-  viewConfig,
-  searchTerm,
-  entityVisibility,
-  characterType,
-  characterSelectedTiers,
-  puzzleSelectedActs,
-  elementBasicTypes,
-  elementStatus,
-}: UseFilteredEntitiesParams): GraphNode[] {
-  return useMemo(() => {
-    // Delegate to existing nodeCreators function
-    // This maintains consistency with current implementation
-    return createAllNodes(
-      characters,
-      elements,
-      puzzles,
-      timeline,
-      searchTerm,
-      entityVisibility,
-      characterType,
-      characterSelectedTiers,
-      puzzleSelectedActs,
-      elementBasicTypes,
-      elementStatus,
-      viewConfig
-    );
-  }, [
-    // Entity arrays
-    characters,
-    elements,
-    puzzles,
-    timeline,
-    // Filter parameters
-    searchTerm,
-    // Entity visibility
-    entityVisibility.characters,
-    entityVisibility.elements,
-    entityVisibility.puzzles,
-    entityVisibility.timeline,
-    // Character filters
-    characterType,
-    characterSelectedTiers.size, // Use size instead of converting to array
-    // Puzzle filters
-    puzzleSelectedActs.size, // Use size instead of converting to array
-    // Element filters
-    elementBasicTypes.size, // Use size instead of converting to array
-    elementStatus.size, // Use size instead of converting to array
-    // View config - use stable references instead of JSON.stringify
-    viewConfig.name,
-    viewConfig.filters,
-    viewConfig.layout,
-    viewConfig.display
-  ]);
-}
\ No newline at end of file
diff --git a/src/hooks/graph/useGraphRelationships.ts b/src/hooks/graph/useGraphRelationships.ts
deleted file mode 100644
index 8c0ee39..0000000
--- a/src/hooks/graph/useGraphRelationships.ts
+++ /dev/null
@@ -1,66 +0,0 @@
-/**
- * useGraphRelationships Hook
- * 
- * Creates edges from entity relationships.
- * Part of the decomposed useGraphLayout architecture.
- * 
- * @module hooks/graph/useGraphRelationships
- * 
- * **Purpose:**
- * Extract edge creation logic from monolithic useGraphLayout.
- * Generates all edges based on entity relationships.
- * 
- * **Performance:**
- * - Memoized to prevent unnecessary recalculation
- * - Only recalculates when entities change
- * - Reduces dependency count by isolating edge logic
- */
-
-import { useMemo } from 'react';
-import type { GraphEdge } from '@/lib/graph/types';
-import { resolveAllRelationships } from '@/lib/graph/relationships';
-import type { Character, Puzzle, TimelineEvent, Element } from '@/types/notion/app';
-
-interface UseGraphRelationshipsParams {
-  // Entity data for relationship resolution
-  characters: Character[];
-  elements: Element[];
-  puzzles: Puzzle[];
-  timeline: TimelineEvent[];
-}
-
-/**
- * Hook to create edges from entity relationships.
- * Encapsulates the edge creation logic from useGraphLayout.
- * 
- * @param params - Entity data for relationship resolution
- * @returns Array of edges representing all entity relationships
- * 
- * @example
- * ```typescript
- * const allEdges = useGraphRelationships({
- *   characters,
- *   elements,
- *   puzzles,
- *   timeline
- * });
- * ```
- */
-export function useGraphRelationships({
-  characters,
-  elements,
-  puzzles,
-  timeline,
-}: UseGraphRelationshipsParams): GraphEdge[] {
-  return useMemo(() => {
-    // Delegate to existing relationships function
-    // This maintains consistency with current implementation
-    return resolveAllRelationships(characters, elements, puzzles, timeline);
-  }, [
-    // Only recalculate when entity data changes
-    characters,
-    elements,
-    puzzles,
-    timeline
-  ]);
-}
\ No newline at end of file
diff --git a/src/hooks/graph/useGraphVisibility.ts b/src/hooks/graph/useGraphVisibility.ts
index d146639..6908391 100644
--- a/src/hooks/graph/useGraphVisibility.ts
+++ b/src/hooks/graph/useGraphVisibility.ts
@@ -27,10 +27,8 @@ interface UseGraphVisibilityParams {
   allEdges: GraphEdge[];
   
   // Visibility controls
-  filterMode: 'pure' | 'connected' | 'focused';
-  focusedNodeId: string | null;
+  selectedNodeId: string | null;
   connectionDepth: number | null;
-  focusRespectFilters: boolean;
 }
 
 interface UseGraphVisibilityResult {
@@ -44,40 +42,34 @@ interface UseGraphVisibilityResult {
  * Encapsulates the visibility logic from useGraphLayout.
  * 
  * @param params - Nodes, edges, and visibility controls
- * @returns Visible nodes and edges based on filter mode
+ * @returns Visible nodes and edges based on selection and depth
  * 
  * @example
  * ```typescript
  * const { visibleNodes, visibleEdges } = useGraphVisibility({
  *   filteredNodes,
  *   allEdges,
- *   filterMode,
- *   focusedNodeId,
- *   connectionDepth,
- *   focusRespectFilters
+ *   selectedNodeId,
+ *   connectionDepth
  * });
  * ```
  */
 export function useGraphVisibility({
   filteredNodes,
   allEdges,
-  filterMode,
-  focusedNodeId,
+  selectedNodeId,
   connectionDepth,
-  focusRespectFilters,
 }: UseGraphVisibilityParams): UseGraphVisibilityResult {
   return useMemo(() => {
     // Step 1: Get IDs of filtered nodes
     const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
     
-    // Step 2: Apply visibility rules based on filter mode
+    // Step 2: Apply visibility rules based on selection and depth
     const visibleNodeIds = getVisibleNodeIds(
-      filterMode,
       filteredNodeIds,
       allEdges,
-      focusedNodeId,
-      connectionDepth,
-      focusRespectFilters
+      selectedNodeId,
+      connectionDepth || 0
     );
     
     // Step 3: Build final nodes with metadata
@@ -92,7 +84,7 @@ export function useGraphVisibility({
           metadata: {
             ...node.data.metadata,
             isFiltered: filteredNodeIds.has(node.id),
-            isFocused: node.id === focusedNodeId
+            isSelected: node.id === selectedNodeId
           }
         }
       }));
@@ -112,9 +104,7 @@ export function useGraphVisibility({
     filteredNodes,
     allEdges,
     // Visibility controls
-    filterMode,
-    focusedNodeId,
-    connectionDepth,
-    focusRespectFilters
+    selectedNodeId,
+    connectionDepth
   ]);
 }
\ No newline at end of file
diff --git a/src/hooks/mutations/entityMutations.ts b/src/hooks/mutations/entityMutations.ts
index ea0aa87..a8f8cbb 100644
--- a/src/hooks/mutations/entityMutations.ts
+++ b/src/hooks/mutations/entityMutations.ts
@@ -12,10 +12,6 @@ import type { UseMutationOptions } from '@tanstack/react-query';
 import toast from 'react-hot-toast';
 import { charactersApi, elementsApi, puzzlesApi, timelineApi } from '@/services/api';
 import { queryKeys } from '@/lib/queryKeys';
-import { 
-  updateRelatedEntities,
-  removeEntityFromCaches
-} from '@/lib/cache/mutations';
 import type { 
   Character, 
   Element, 
@@ -109,12 +105,12 @@ export function useCreateCharacter(
   
   return useMutation<Character, MutationError, Partial<Character> & ParentRelationMetadata>({
     mutationFn: async (data) => {
-      // Extract parent relation metadata if present
-      const { _parentRelation, ...entityData } = data;
+      // Don't extract _parentRelation - pass complete data to API
+      // The backend handles _parentRelation atomically
       
       // Validate relationships in parallel if needed
-      const needsElementValidation = entityData.ownedElementIds?.length || entityData.associatedElementIds?.length;
-      const needsPuzzleValidation = entityData.characterPuzzleIds?.length;
+      const needsElementValidation = data.ownedElementIds?.length || data.associatedElementIds?.length;
+      const needsPuzzleValidation = data.characterPuzzleIds?.length;
       
       if (needsElementValidation || needsPuzzleValidation) {
         // Fetch both element and puzzle lists in parallel
@@ -127,8 +123,8 @@ export function useCreateCharacter(
         if (needsElementValidation) {
           const elementIds = elements.map(e => e.id);
           
-          const invalidOwned = entityData.ownedElementIds?.filter(id => !elementIds.includes(id)) || [];
-          const invalidAssoc = entityData.associatedElementIds?.filter(id => !elementIds.includes(id)) || [];
+          const invalidOwned = data.ownedElementIds?.filter(id => !elementIds.includes(id)) || [];
+          const invalidAssoc = data.associatedElementIds?.filter(id => !elementIds.includes(id)) || [];
           
           if (invalidOwned.length > 0) {
             throw new Error(`Invalid owned element IDs: ${invalidOwned.join(', ')}`);
@@ -142,36 +138,21 @@ export function useCreateCharacter(
         if (needsPuzzleValidation) {
           const puzzleIds = puzzles.map(p => p.id);
           
-          const invalidPuzzles = entityData.characterPuzzleIds!.filter(id => !puzzleIds.includes(id));
+          const invalidPuzzles = data.characterPuzzleIds!.filter(id => !puzzleIds.includes(id));
           if (invalidPuzzles.length > 0) {
             throw new Error(`Invalid puzzle IDs: ${invalidPuzzles.join(', ')}`);
           }
         }
       }
       
-      return await charactersApi.create(entityData);
+      return await charactersApi.create(data);
     },
     
-    onSuccess: (character, variables) => {
-      // Track cache updates for performance monitoring
-      if (perfLog) {
-        perfLog.cacheUpdates++;
-      }
-      
-      // Add to list cache
-      queryClient.setQueryData(
-        queryKeys.characters(),
-        (old: Character[] = []) => [...old, character]
-      );
-      
-      // Set individual cache
-      queryClient.setQueryData(
-        queryKeys.character(character.id),
-        character
-      );
-      
-      // Parent relation updates are handled server-side atomically
-      // This prevents dual cache updates and race conditions
+    onSuccess: async (character, variables) => {
+      // Simple: just invalidate the graph
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
+      });
       
       toast.success(`Created ${character.name || 'character'}`);
       options?.onSuccess?.(character, variables, undefined);
@@ -198,30 +179,10 @@ export function useUpdateCharacter(
     },
     
     onSuccess: async (character, variables) => {
-      // Update list cache
-      queryClient.setQueryData(
-        queryKeys.characters(),
-        (old: Character[] = []) => 
-          old.map(c => c.id === character.id ? character : c)
-      );
-      
-      // Update individual cache
-      queryClient.setQueryData(
-        queryKeys.character(character.id),
-        character
-      );
-      
-      // Update related entities with bidirectional relationships
-      const updatedFields = Object.entries(variables).reduce<Partial<Character>>((acc, [key, value]) => {
-        if (key !== 'id' && value !== undefined) {
-          return { ...acc, [key]: value };
-        }
-        return acc;
-      }, {});
-      
-      if (Object.keys(updatedFields).length > 0) {
-        updateRelatedEntities(queryClient, 'characters', character, updatedFields);
-      }
+      // Simple: just invalidate the graph
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
+      });
       
       toast.success(`Updated ${character.name || 'character'}`);
       options?.onSuccess?.(character, variables, undefined);
@@ -247,9 +208,11 @@ export function useDeleteCharacter(
       return await charactersApi.delete(id);
     },
     
-    onSuccess: (_, id) => {
-      // Remove from caches
-      removeEntityFromCaches(queryClient, 'characters', id);
+    onSuccess: async (_, id) => {
+      // Simple: just invalidate the graph
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
+      });
       
       toast.success('Character deleted');
       options?.onSuccess?.(undefined, id, undefined);
@@ -276,27 +239,16 @@ export function useCreateElement(
   
   return useMutation<Element, MutationError, Partial<Element> & ParentRelationMetadata>({
     mutationFn: async (data) => {
-      // Extract parent relation metadata if present
-      const { _parentRelation, ...entityData } = data;
-      return await elementsApi.create(entityData);
+      // Don't extract _parentRelation - pass complete data to API
+      // The backend handles _parentRelation atomically
+      return await elementsApi.create(data);
     },
     
-    onSuccess: (element, variables) => {
-      if (perfLog) {
-        perfLog.cacheUpdates++;
-      }
-      
-      // Add to list cache
-      queryClient.setQueryData(
-        queryKeys.elements(),
-        (old: Element[] = []) => [...old, element]
-      );
-      
-      // Set individual cache
-      queryClient.setQueryData(
-        queryKeys.element(element.id),
-        element
-      );
+    onSuccess: async (element, variables) => {
+      // Simple: just invalidate the graph
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
+      });
       
       toast.success(`Created ${element.name || 'element'}`);
       options?.onSuccess?.(element, variables, undefined);
@@ -323,30 +275,10 @@ export function useUpdateElement(
     },
     
     onSuccess: async (element, variables) => {
-      // Update list cache
-      queryClient.setQueryData(
-        queryKeys.elements(),
-        (old: Element[] = []) => 
-          old.map(e => e.id === element.id ? element : e)
-      );
-      
-      // Update individual cache
-      queryClient.setQueryData(
-        queryKeys.element(element.id),
-        element
-      );
-      
-      // Update related entities with bidirectional relationships
-      const updatedFields = Object.entries(variables).reduce<Partial<Element>>((acc, [key, value]) => {
-        if (key !== 'id' && value !== undefined) {
-          return { ...acc, [key]: value };
-        }
-        return acc;
-      }, {});
-      
-      if (Object.keys(updatedFields).length > 0) {
-        updateRelatedEntities(queryClient, 'elements', element, updatedFields);
-      }
+      // Simple: just invalidate the graph
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
+      });
       
       toast.success(`Updated ${element.name || 'element'}`);
       options?.onSuccess?.(element, variables, undefined);
@@ -372,9 +304,11 @@ export function useDeleteElement(
       return await elementsApi.delete(id);
     },
     
-    onSuccess: (_, id) => {
-      // Remove from caches
-      removeEntityFromCaches(queryClient, 'elements', id);
+    onSuccess: async (_, id) => {
+      // Simple: just invalidate the graph
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
+      });
       
       toast.success('Element deleted');
       options?.onSuccess?.(undefined, id, undefined);
@@ -401,11 +335,11 @@ export function useCreatePuzzle(
   
   return useMutation<Puzzle, MutationError, Partial<Puzzle> & ParentRelationMetadata>({
     mutationFn: async (data) => {
-      // Extract parent relation metadata if present
-      const { _parentRelation, ...entityData } = data;
+      // Don't extract _parentRelation - pass complete data to API
+      // The backend handles _parentRelation atomically
       
       // Validate relationships - using Promise.all pattern for consistency and future expansion
-      const needsElementValidation = entityData.rewardIds?.length || entityData.puzzleElementIds?.length;
+      const needsElementValidation = data.rewardIds?.length || data.puzzleElementIds?.length;
       
       if (needsElementValidation) {
         // Fetch element list (could add more validations in parallel in future)
@@ -416,41 +350,30 @@ export function useCreatePuzzle(
         const elementIds = elements.map(e => e.id);
         
         // Validate reward elements
-        if (entityData.rewardIds?.length) {
-          const invalidRewards = entityData.rewardIds.filter(id => !elementIds.includes(id));
+        if (data.rewardIds?.length) {
+          const invalidRewards = data.rewardIds.filter(id => !elementIds.includes(id));
           if (invalidRewards.length > 0) {
             throw new Error(`Invalid reward element IDs: ${invalidRewards.join(', ')}`);
           }
         }
         
         // Validate puzzle elements (requirements)
-        if (entityData.puzzleElementIds?.length) {
-          const invalidRequirements = entityData.puzzleElementIds.filter(id => !elementIds.includes(id));
+        if (data.puzzleElementIds?.length) {
+          const invalidRequirements = data.puzzleElementIds.filter(id => !elementIds.includes(id));
           if (invalidRequirements.length > 0) {
             throw new Error(`Invalid puzzle element IDs: ${invalidRequirements.join(', ')}`);
           }
         }
       }
       
-      return await puzzlesApi.create(entityData);
+      return await puzzlesApi.create(data);
     },
     
-    onSuccess: (puzzle, variables) => {
-      if (perfLog) {
-        perfLog.cacheUpdates++;
-      }
-      
-      // Add to list cache
-      queryClient.setQueryData(
-        queryKeys.puzzles(),
-        (old: Puzzle[] = []) => [...old, puzzle]
-      );
-      
-      // Set individual cache
-      queryClient.setQueryData(
-        queryKeys.puzzle(puzzle.id),
-        puzzle
-      );
+    onSuccess: async (puzzle, variables) => {
+      // Simple: just invalidate the graph
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
+      });
       
       toast.success(`Created ${puzzle.name || 'puzzle'}`);
       options?.onSuccess?.(puzzle, variables, undefined);
@@ -477,30 +400,10 @@ export function useUpdatePuzzle(
     },
     
     onSuccess: async (puzzle, variables) => {
-      // Update list cache
-      queryClient.setQueryData(
-        queryKeys.puzzles(),
-        (old: Puzzle[] = []) => 
-          old.map(p => p.id === puzzle.id ? puzzle : p)
-      );
-      
-      // Update individual cache
-      queryClient.setQueryData(
-        queryKeys.puzzle(puzzle.id),
-        puzzle
-      );
-      
-      // Update related entities with bidirectional relationships
-      const updatedFields = Object.entries(variables).reduce<Partial<Puzzle>>((acc, [key, value]) => {
-        if (key !== 'id' && value !== undefined) {
-          return { ...acc, [key]: value };
-        }
-        return acc;
-      }, {});
-      
-      if (Object.keys(updatedFields).length > 0) {
-        updateRelatedEntities(queryClient, 'puzzles', puzzle, updatedFields);
-      }
+      // Simple: just invalidate the graph
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
+      });
       
       toast.success(`Updated ${puzzle.name || 'puzzle'}`);
       options?.onSuccess?.(puzzle, variables, undefined);
@@ -526,9 +429,11 @@ export function useDeletePuzzle(
       return await puzzlesApi.delete(id);
     },
     
-    onSuccess: (_, id) => {
-      // Remove from caches
-      removeEntityFromCaches(queryClient, 'puzzles', id);
+    onSuccess: async (_, id) => {
+      // Simple: just invalidate the graph
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
+      });
       
       toast.success('Puzzle deleted');
       options?.onSuccess?.(undefined, id, undefined);
@@ -555,27 +460,16 @@ export function useCreateTimeline(
   
   return useMutation<TimelineEvent, MutationError, Partial<TimelineEvent> & ParentRelationMetadata>({
     mutationFn: async (data) => {
-      // Extract parent relation metadata if present
-      const { _parentRelation, ...entityData } = data;
-      return await timelineApi.create(entityData);
+      // Don't extract _parentRelation - pass complete data to API
+      // The backend handles _parentRelation atomically
+      return await timelineApi.create(data);
     },
     
-    onSuccess: (event, variables) => {
-      if (perfLog) {
-        perfLog.cacheUpdates++;
-      }
-      
-      // Add to list cache
-      queryClient.setQueryData(
-        queryKeys.timeline(),
-        (old: TimelineEvent[] = []) => [...old, event]
-      );
-      
-      // Set individual cache
-      queryClient.setQueryData(
-        queryKeys.timelineEvent(event.id),
-        event
-      );
+    onSuccess: async (event, variables) => {
+      // Simple: just invalidate the graph
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
+      });
       
       toast.success('Created timeline event');
       options?.onSuccess?.(event, variables, undefined);
@@ -602,30 +496,10 @@ export function useUpdateTimeline(
     },
     
     onSuccess: async (event, variables) => {
-      // Update list cache
-      queryClient.setQueryData(
-        queryKeys.timeline(),
-        (old: TimelineEvent[] = []) => 
-          old.map(e => e.id === event.id ? event : e)
-      );
-      
-      // Update individual cache
-      queryClient.setQueryData(
-        queryKeys.timelineEvent(event.id),
-        event
-      );
-      
-      // Update related entities with bidirectional relationships
-      const updatedFields = Object.entries(variables).reduce<Partial<TimelineEvent>>((acc, [key, value]) => {
-        if (key !== 'id' && value !== undefined) {
-          return { ...acc, [key]: value };
-        }
-        return acc;
-      }, {});
-      
-      if (Object.keys(updatedFields).length > 0) {
-        updateRelatedEntities(queryClient, 'timeline', event, updatedFields);
-      }
+      // Simple: just invalidate the graph
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
+      });
       
       toast.success('Updated timeline event');
       options?.onSuccess?.(event, variables, undefined);
@@ -651,9 +525,11 @@ export function useDeleteTimeline(
       return await timelineApi.delete(id);
     },
     
-    onSuccess: (_, id) => {
-      // Remove from caches
-      removeEntityFromCaches(queryClient, 'timeline', id);
+    onSuccess: async (_, id) => {
+      // Simple: just invalidate the graph
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
+      });
       
       toast.success('Timeline event deleted');
       options?.onSuccess?.(undefined, id, undefined);
@@ -689,8 +565,8 @@ export function useBatchEntityMutation<T extends Entity>(
       const results = await Promise.all(
         updates.map(update => {
           if (!update.id) throw new Error('ID required for batch update');
-          const { _parentRelation, ...entityData } = update;
-          return apiModule.update(update.id, entityData);
+          // Pass complete update including any metadata
+          return apiModule.update(update.id, update);
         })
       );
       
@@ -698,47 +574,12 @@ export function useBatchEntityMutation<T extends Entity>(
     },
     
     onSuccess: async (response, variables) => {
-      const entityQueryKey = getQueryKeyForType(entityType);
-      const updatedEntities = response; // Response is the array directly
-      
-      // Surgical batch update in list cache
-      queryClient.setQueryData(entityQueryKey, (oldData: T[] | undefined) => {
-        if (!oldData) return updatedEntities;
-        
-        // Create map of updated entities for efficient lookup
-        const updateMap = new Map(updatedEntities.map(e => [e.id, e]));
-        
-        // Replace updated entities in the list
-        return oldData.map(item => updateMap.get(item.id) || item);
+      // Simple: just invalidate the graph after batch update
+      await queryClient.invalidateQueries({ 
+        queryKey: ['graph', 'complete'] 
       });
       
-      // Update individual entity caches
-      for (const entity of updatedEntities) {
-        queryClient.setQueryData([...entityQueryKey, entity.id], entity);
-      }
-      
-      // Update related entities for each updated entity
-      // Use surgical cache updates instead of broad invalidation
-      for (let i = 0; i < updatedEntities.length; i++) {
-        const entity = updatedEntities[i];
-        const originalUpdate = variables[i];
-        
-        // Skip if no matching update or entity
-        if (!entity || !originalUpdate) continue;
-        
-        // Extract the fields that were actually updated (excluding id and metadata)
-        const updatedFields = Object.entries(originalUpdate).reduce<Partial<T>>((acc, [key, value]) => {
-          if (key !== 'id' && key !== '_parentRelation' && value !== undefined) {
-            return { ...acc, [key]: value };
-          }
-          return acc;
-        }, {});
-        
-        // If any fields were updated, surgically update related entities
-        if (Object.keys(updatedFields).length > 0) {
-          updateRelatedEntities(queryClient, entityType, entity, updatedFields);
-        }
-      }
+      toast.success(`Updated ${response.length} entities`);
     }
   });
 }
\ No newline at end of file
diff --git a/src/hooks/mutations/index.ts b/src/hooks/mutations/index.ts
index 69c8706..7f8534d 100644
--- a/src/hooks/mutations/index.ts
+++ b/src/hooks/mutations/index.ts
@@ -63,7 +63,4 @@ export {
   type MutationType,
   type Entity,
   type MutationPayload
-} from './entityMutations';
-
-// Also export relationship update hook and validation
-export { useUpdateRelationship } from './updateRelationship';
\ No newline at end of file
+} from './entityMutations';
\ No newline at end of file
diff --git a/src/hooks/mutations/updateRelationship.ts b/src/hooks/mutations/updateRelationship.ts
deleted file mode 100644
index b6fec3f..0000000
--- a/src/hooks/mutations/updateRelationship.ts
+++ /dev/null
@@ -1,169 +0,0 @@
-/**
- * Update Relationship Mutation Hook
- * 
- * Handles updating parent entity relationships when a new entity
- * is created from a relation field editor.
- * 
- * @module hooks/mutations/updateRelationship
- */
-
-import { useMutation, useQueryClient } from '@tanstack/react-query';
-import { charactersApi, elementsApi, puzzlesApi, timelineApi } from '@/services/api';
-import { queryKeys } from '@/lib/queryKeys';
-import { 
-  updateEntityCaches, 
-  type EntityType,
-  type Entity 
-} from '@/lib/cache/mutations';
-import toast from 'react-hot-toast';
-
-/**
- * Get the appropriate API based on entity type
- */
-function getApiForType(entityType: string): any {
-  switch (entityType) {
-    case 'character':
-    case 'characters':
-      return charactersApi;
-    case 'element':
-    case 'elements':
-      return elementsApi;
-    case 'puzzle':
-    case 'puzzles':
-      return puzzlesApi;
-    case 'timeline':
-      return timelineApi;
-    default:
-      return null;
-  }
-}
-
-/**
- * Convert singular entity type to plural for EntityType
- */
-function toEntityType(type: string): EntityType {
-  switch (type) {
-    case 'character':
-      return 'characters';
-    case 'element':
-      return 'elements';
-    case 'puzzle':
-      return 'puzzles';
-    case 'timeline':
-      return 'timeline';
-    default:
-      return 'timeline'; // fallback
-  }
-}
-
-// Field mapping now handled by centralized cache utilities
-// See: src/lib/cache/mutations.ts - FIELD_TO_ENTITY_TYPE_MAP
-
-/**
- * Hook for updating entity relationships.
- * Used when creating a new entity from a relation field.
- * 
- * @example
- * ```tsx
- * const updateRelationship = useUpdateRelationship();
- * 
- * await updateRelationship.mutateAsync({
- *   parentType: 'puzzle',
- *   parentId: 'abc123',
- *   fieldKey: 'prerequisites',
- *   newEntityId: 'xyz789'
- * });
- * ```
- */
-export function useUpdateRelationship() {
-  const queryClient = useQueryClient();
-  
-  return useMutation({
-    mutationFn: async ({
-      parentType,
-      parentId,
-      fieldKey,
-      newEntityId
-    }: {
-      parentType: string;
-      parentId: string;
-      fieldKey: string;
-      newEntityId: string;
-    }) => {
-      console.log('[UpdateRelationship] Updating relationship', {
-        parentType,
-        parentId,
-        fieldKey,
-        newEntityId
-      });
-      
-      const api = getApiForType(parentType);
-      if (!api) {
-        throw new Error(`Unknown entity type: ${parentType}`);
-      }
-      
-      // Get the query key for the parent entity type
-      const queryKey = 
-        parentType === 'character' ? queryKeys.characters() :
-        parentType === 'element' ? queryKeys.elements() :
-        parentType === 'puzzle' ? queryKeys.puzzles() :
-        queryKeys.timeline();
-      
-      // Get current parent entity from cache
-      const cachedData = queryClient.getQueryData<any[]>(queryKey);
-      const parent = cachedData?.find((entity: any) => entity.id === parentId);
-      
-      if (!parent) {
-        throw new Error(`Parent entity not found in cache: ${parentId}`);
-      }
-      
-      // Update the relationship field
-      const currentValue = parent[fieldKey];
-      let updatedValue: any;
-      
-      if (Array.isArray(currentValue)) {
-        // Multi-relation field - add to array
-        updatedValue = [...currentValue, newEntityId];
-      } else if (typeof currentValue === 'string' || currentValue === null || currentValue === undefined) {
-        // Single-relation field - replace value
-        updatedValue = newEntityId;
-      } else {
-        // Unknown field type
-        console.warn(`[UpdateRelationship] Unknown field type for ${fieldKey}:`, typeof currentValue);
-        updatedValue = newEntityId;
-      }
-      
-      console.log('[UpdateRelationship] Updating field', {
-        fieldKey,
-        currentValue,
-        updatedValue
-      });
-      
-      // Save the update
-      return api.update(parentId, {
-        ...parent,
-        [fieldKey]: updatedValue
-      });
-    },
-    
-    onSuccess: async (updatedEntity: Entity, variables) => {
-      // Convert parent type to EntityType format
-      const parentEntityType = toEntityType(variables.parentType);
-      
-      // Surgically update the parent entity in cache
-      updateEntityCaches(queryClient, parentEntityType, updatedEntity);
-      
-      // Note: Child entity caches don't need updating here since
-      // the child entity itself hasn't changed - only the parent's
-      // reference to it. If bidirectional updates are needed,
-      // they should be handled by the backend or in a separate mutation.
-      
-      toast.success('Relationship updated');
-    },
-    
-    onError: (error) => {
-      console.error('[UpdateRelationship] Error:', error);
-      toast.error('Failed to update relationship');
-    }
-  });
-}
\ No newline at end of file
diff --git a/src/hooks/useCacheSync.ts b/src/hooks/useCacheSync.ts
deleted file mode 100644
index 2200bae..0000000
--- a/src/hooks/useCacheSync.ts
+++ /dev/null
@@ -1,213 +0,0 @@
-/**
- * Cache Synchronization Hook
- * 
- * Provides cache version synchronization between frontend and backend.
- * Monitors cache version changes and triggers necessary invalidations
- * to ensure data consistency across boundaries.
- * 
- * @module hooks/useCacheSync
- */
-
-import { useEffect, useCallback } from 'react';
-import { useQueryClient } from '@tanstack/react-query';
-import { cacheVersionManager } from '@/lib/cache/CacheVersionManager';
-
-/**
- * Options for cache synchronization
- */
-interface UseCacheSyncOptions {
-  /**
-   * Enable automatic version checking on interval
-   */
-  autoSync?: boolean;
-  /**
-   * Interval for automatic version checking (ms)
-   * Default: 30000 (30 seconds)
-   */
-  syncInterval?: number;
-  /**
-   * Callback when version mismatch detected
-   */
-  onVersionMismatch?: (oldVersion: string | null, newVersion: string) => void;
-  /**
-   * Entity types to monitor for version changes
-   */
-  entityTypes?: string[];
-}
-
-/**
- * Hook for cache synchronization with backend
- * 
- * @example
- * ```tsx
- * function MyComponent() {
- *   const { checkVersion, currentVersion, isStale } = useCacheSync({
- *     autoSync: true,
- *     syncInterval: 30000,
- *     onVersionMismatch: (oldVersion, newVersion) => {
- *       console.log('Cache version changed:', oldVersion, '->', newVersion);
- *     }
- *   });
- * 
- *   // Manually check version
- *   const handleRefresh = () => {
- *     checkVersion();
- *   };
- * }
- * ```
- */
-export function useCacheSync(options: UseCacheSyncOptions = {}) {
-  const {
-    autoSync = false,
-    syncInterval = 30000,
-    onVersionMismatch,
-    entityTypes = []
-  } = options;
-
-  const queryClient = useQueryClient();
-
-  /**
-   * Manually check cache version with backend
-   * Makes a lightweight request to check version headers
-   */
-  const checkVersion = useCallback(async () => {
-    try {
-      // Make a lightweight request to check cache version
-      const response = await fetch('/api/cache/version', {
-        method: 'HEAD',
-        headers: {
-          'X-Client-Cache-Version': cacheVersionManager.getCurrentVersion() || ''
-        }
-      });
-
-      // Process version headers
-      const serverVersion = response.headers.get('X-Cache-Version');
-      const clientVersion = cacheVersionManager.getCurrentVersion();
-
-      if (serverVersion && serverVersion !== clientVersion) {
-        console.debug(`[useCacheSync] Version mismatch detected: ${clientVersion} -> ${serverVersion}`);
-        
-        // Call the callback if provided
-        onVersionMismatch?.(clientVersion, serverVersion);
-        
-        // The CacheVersionManager will handle invalidation
-        // when it processes the headers
-      }
-
-      // Check entity-specific versions
-      for (const entityType of entityTypes) {
-        const entityVersionHeader = response.headers.get(`X-Entity-Version-${entityType}`);
-        if (entityVersionHeader) {
-          const currentEntityVersion = cacheVersionManager.getEntityVersion(entityType);
-          if (currentEntityVersion && currentEntityVersion !== entityVersionHeader) {
-            console.debug(`[useCacheSync] Entity version mismatch for ${entityType}: ${currentEntityVersion} -> ${entityVersionHeader}`);
-            // CacheVersionManager handles the invalidation
-          }
-        }
-      }
-    } catch (error) {
-      console.error('[useCacheSync] Failed to check cache version:', error);
-    }
-  }, [onVersionMismatch, entityTypes]);
-
-  /**
-   * Force invalidate all queries
-   */
-  const forceInvalidate = useCallback(() => {
-    queryClient.invalidateQueries();
-    cacheVersionManager.reset();
-  }, [queryClient]);
-
-  /**
-   * Check if cache is potentially stale
-   */
-  const isStale = useCallback((): boolean => {
-    const version = cacheVersionManager.getCurrentVersion();
-    return version === null;
-  }, []);
-
-  // Set up automatic version checking
-  useEffect(() => {
-    if (!autoSync) return;
-
-    const interval = setInterval(checkVersion, syncInterval);
-
-    // Check immediately on mount
-    checkVersion();
-
-    return () => clearInterval(interval);
-  }, [autoSync, syncInterval, checkVersion]);
-
-  // Listen for online/offline events
-  useEffect(() => {
-    const handleOnline = () => {
-      console.debug('[useCacheSync] Network reconnected, checking cache version');
-      checkVersion();
-    };
-
-    window.addEventListener('online', handleOnline);
-
-    return () => {
-      window.removeEventListener('online', handleOnline);
-    };
-  }, [checkVersion]);
-
-  // Listen for visibility changes
-  useEffect(() => {
-    const handleVisibilityChange = () => {
-      if (!document.hidden) {
-        console.debug('[useCacheSync] Tab became visible, checking cache version');
-        checkVersion();
-      }
-    };
-
-    document.addEventListener('visibilitychange', handleVisibilityChange);
-
-    return () => {
-      document.removeEventListener('visibilitychange', handleVisibilityChange);
-    };
-  }, [checkVersion]);
-
-  return {
-    /**
-     * Current cache version
-     */
-    currentVersion: cacheVersionManager.getCurrentVersion(),
-    /**
-     * Manually check cache version
-     */
-    checkVersion,
-    /**
-     * Force invalidate all caches
-     */
-    forceInvalidate,
-    /**
-     * Check if cache is potentially stale
-     */
-    isStale: isStale(),
-    /**
-     * Get version for specific entity type
-     */
-    getEntityVersion: (entityType: string) => cacheVersionManager.getEntityVersion(entityType),
-    /**
-     * Check if a version is valid
-     */
-    isVersionValid: (version: string) => cacheVersionManager.isVersionValid(version),
-  };
-}
-
-/**
- * Hook to use cache sync at app level
- * This is a convenience hook for app-wide cache synchronization
- */
-export function useAppCacheSync() {
-  return useCacheSync({
-    autoSync: true,
-    syncInterval: 30000, // Check every 30 seconds
-    entityTypes: ['characters', 'elements', 'puzzles', 'timeline'],
-    onVersionMismatch: (oldVersion, newVersion) => {
-      console.log(`Cache version updated from ${oldVersion} to ${newVersion}`);
-      // Could show a toast notification here
-    }
-  });
-}
\ No newline at end of file
diff --git a/src/hooks/useFilterSelectors.ts b/src/hooks/useFilterSelectors.ts
index 22bd254..cc19590 100644
--- a/src/hooks/useFilterSelectors.ts
+++ b/src/hooks/useFilterSelectors.ts
@@ -26,18 +26,15 @@ export interface FilterSelectors {
   // Search and selection
   searchTerm: string;
   selectedNodeId: string | null;
-  focusedNodeId: string | null;
   
   // Graph filtering
   connectionDepth: number | null;
-  filterMode: 'pure' | 'connected' | 'focused';
-  focusRespectFilters: boolean;
   
   // Entity visibility
   entityVisibility: {
-    characters: boolean;
-    puzzles: boolean;
-    elements: boolean;
+    character: boolean;
+    puzzle: boolean;
+    element: boolean;
     timeline: boolean;
   };
   
@@ -54,7 +51,6 @@ export interface FilterSelectors {
   
   // Actions (not part of filter state, but needed by GraphView)
   setSelectedNode: (nodeId: string | null) => void;
-  setFocusedNode: (nodeId: string | null) => void;
   hasActiveFilters: () => boolean;
 }
 
@@ -87,12 +83,9 @@ export function useFilterSelectors(): FilterSelectors {
     // Search and selection
     searchTerm: state.searchTerm,
     selectedNodeId: state.selectedNodeId,
-    focusedNodeId: state.focusedNodeId,
     
     // Graph filtering
     connectionDepth: state.connectionDepth,
-    filterMode: state.filterMode,
-    focusRespectFilters: state.focusRespectFilters,
     
     // Entity visibility
     entityVisibility: state.entityVisibility,
@@ -110,7 +103,6 @@ export function useFilterSelectors(): FilterSelectors {
     
     // Actions
     setSelectedNode: state.setSelectedNode,
-    setFocusedNode: state.setFocusedNode,
     hasActiveFilters: state.hasActiveFilters,
   })));
 }
@@ -125,10 +117,7 @@ export function useFilterValues() {
   return useFilterStore(useShallow((state) => ({
     searchTerm: state.searchTerm,
     selectedNodeId: state.selectedNodeId,
-    focusedNodeId: state.focusedNodeId,
     connectionDepth: state.connectionDepth,
-    filterMode: state.filterMode,
-    focusRespectFilters: state.focusRespectFilters,
     entityVisibility: state.entityVisibility,
     characterSelectedTiers: state.characterFilters.selectedTiers,
     characterType: state.characterFilters.characterType,
@@ -147,10 +136,8 @@ export function useFilterValues() {
 export function useFilterActions() {
   return useFilterStore(useShallow((state) => ({
     setSelectedNode: state.setSelectedNode,
-    setFocusedNode: state.setFocusedNode,
     setSearchTerm: state.setSearchTerm,
     setConnectionDepth: state.setConnectionDepth,
-    setFilterMode: state.setFilterMode,
     toggleEntityVisibility: state.toggleEntityVisibility,
     hasActiveFilters: state.hasActiveFilters,
   })));
diff --git a/src/hooks/useGraphLayout.ts b/src/hooks/useGraphLayout.ts
index 3ed0fec..de3e43e 100644
--- a/src/hooks/useGraphLayout.ts
+++ b/src/hooks/useGraphLayout.ts
@@ -19,32 +19,25 @@
 
 import { useMemo } from 'react';
 import type { GraphNode } from '@/lib/graph/types';
-import type { Edge } from '@xyflow/react';
-import type { Character, Puzzle, TimelineEvent, Element } from '@/types/notion/app';
+import type { Node, Edge } from '@xyflow/react';
 import type { ViewConfig } from '@/lib/viewConfigs';
 
-// Import the 4 composable hooks
-import { useFilteredEntities } from './graph/useFilteredEntities';
-import { useGraphRelationships } from './graph/useGraphRelationships';
+// Import the 2 composable hooks (filtering is now inline, relationships come from server)
 import { useGraphVisibility } from './graph/useGraphVisibility';
 import { useLayoutEngine } from './graph/useLayoutEngine';
 
 interface UseGraphLayoutParams {
-  characters: Character[];
-  elements: Element[];
-  puzzles: Puzzle[];
-  timeline: TimelineEvent[];
+  nodes: Node[];
+  edges: Edge[];
   viewConfig: ViewConfig;
   // Individual filter values to avoid object recreation
   searchTerm: string;
-  focusedNodeId: string | null;
+  selectedNodeId: string | null;
   connectionDepth: number | null;
-  filterMode: 'pure' | 'connected' | 'focused';
-  focusRespectFilters: boolean;
   entityVisibility: {
-    characters: boolean;
-    elements: boolean;
-    puzzles: boolean;
+    character: boolean;
+    element: boolean;
+    puzzle: boolean;
     timeline: boolean;
   };
   // Character filter primitives
@@ -68,8 +61,8 @@ interface UseGraphLayoutResult {
  * Each sub-hook manages its own memoization for optimal performance.
  * 
  * **Pipeline:**
- * 1. useFilteredEntities → Create filtered nodes
- * 2. useGraphRelationships → Generate edges
+ * 1. Apply filters to server-provided nodes
+ * 2. Use server-provided edges directly
  * 3. useGraphVisibility → Apply visibility rules
  * 4. useLayoutEngine → Position nodes
  * 
@@ -89,16 +82,12 @@ interface UseGraphLayoutResult {
  * ```
  */
 export const useGraphLayout = ({
-  characters,
-  elements,
-  puzzles,
-  timeline,
+  nodes,
+  edges,
   viewConfig,
   searchTerm,
-  focusedNodeId,
+  selectedNodeId,
   connectionDepth,
-  filterMode,
-  focusRespectFilters,
   entityVisibility,
   characterType,
   characterSelectedTiers,
@@ -107,41 +96,87 @@ export const useGraphLayout = ({
   elementStatus,
 }: UseGraphLayoutParams): UseGraphLayoutResult => {
   
-  // Step 1: Create filtered nodes
-  // This hook memoizes based on entities and filter criteria
-  const filteredNodes = useFilteredEntities({
-    characters,
-    elements,
-    puzzles,
-    timeline,
-    viewConfig,
-    searchTerm,
-    entityVisibility,
-    characterType,
-    characterSelectedTiers,
-    puzzleSelectedActs,
-    elementBasicTypes,
-    elementStatus,
-  });
+  // Step 1: Apply filters to server-provided nodes
+  // Convert server nodes to GraphNodes and apply filters
+  const filteredNodes = useMemo(() => {
+    return nodes
+      .filter((node: any) => {
+        // Skip placeholder nodes unless we want to show them
+        if (node.data?.metadata?.isPlaceholder) {
+          // TODO: Add option to show/hide placeholder nodes
+          return true; // Show them for now to visualize data issues
+        }
+        
+        // Apply search filter
+        const label = node.data?.label;
+        if (searchTerm && label && typeof label === 'string') {
+          if (!label.toLowerCase().includes(searchTerm.toLowerCase())) {
+            return false;
+          }
+        }
+        
+        // Apply entity visibility filters
+        const entityType = node.data?.metadata?.entityType;
+        if (entityType && typeof entityType === 'string') {
+          if (!entityVisibility[entityType as keyof typeof entityVisibility]) {
+            return false;
+          }
+          
+          // Apply entity-specific filters
+          const entity = node.data?.entity;
+          if (entity) {
+            switch (entityType) {
+              case 'character':
+                // Character type filter
+                if (characterType && characterType !== 'all' && entity.type !== characterType) {
+                  return false;
+                }
+                // Character tier filter
+                if (characterSelectedTiers.size > 0 && !characterSelectedTiers.has(entity.tier || '')) {
+                  return false;
+                }
+                break;
+                
+              case 'puzzle':
+                // Puzzle act filter
+                if (puzzleSelectedActs.size > 0 && !puzzleSelectedActs.has(entity.act || '')) {
+                  return false;
+                }
+                break;
+                
+              case 'element':
+                // Element type filter
+                if (elementBasicTypes.size > 0 && !elementBasicTypes.has(entity.basicType || '')) {
+                  return false;
+                }
+                // Element status filter
+                if (elementStatus.size > 0 && !elementStatus.has(entity.status || '')) {
+                  return false;
+                }
+                break;
+            }
+          }
+        }
+        
+        return true;
+      })
+      .map(node => ({
+        ...node,
+        type: node.type || 'default',
+      } as GraphNode));
+  }, [nodes, searchTerm, entityVisibility, characterType, characterSelectedTiers, 
+      puzzleSelectedActs, elementBasicTypes, elementStatus]);
   
-  // Step 2: Create all edges from relationships
-  // This hook memoizes based on entity data only
-  const allEdges = useGraphRelationships({
-    characters,
-    elements,
-    puzzles,
-    timeline,
-  });
+  // Step 2: Use server-provided edges directly, ensuring type compatibility
+  const allEdges = edges as any[];
   
   // Step 3: Apply visibility rules
-  // This hook memoizes based on filter mode and focus
+  // This hook memoizes based on selection and connection depth
   const { visibleNodes, visibleEdges } = useGraphVisibility({
     filteredNodes,
     allEdges,
-    filterMode,
-    focusedNodeId,
+    selectedNodeId,
     connectionDepth,
-    focusRespectFilters,
   });
   
   // Step 4: Apply layout to visible nodes
@@ -153,7 +188,7 @@ export const useGraphLayout = ({
   });
   
   // Calculate total universe size for UI feedback
-  const totalUniverseNodes = characters.length + elements.length + puzzles.length + timeline.length;
+  const totalUniverseNodes = nodes.length;
   
   // Safely map GraphEdge[] to Edge[] for React Flow compatibility
   // This ensures data integrity is preserved during the conversion
diff --git a/src/hooks/useGraphState.ts b/src/hooks/useGraphState.ts
index 7cc0ec5..bf4d8d2 100644
--- a/src/hooks/useGraphState.ts
+++ b/src/hooks/useGraphState.ts
@@ -153,21 +153,20 @@ function useGraphViewport() {
  * Hook for intelligent viewport management with priority-based focusing
  * 
  * Implements smart viewport logic:
- * - Selected node (from search dropdown) takes highest priority
+ * - Selected node takes highest priority
  * - Search results take high priority
- * - Focused nodes (connection depth filtering) take medium priority  
  * - All visible nodes take lowest priority
  * 
  * @param searchTerm Current search query
- * @param selectedNodeId Specifically selected node from search
- * @param focusedNodeId Currently focused node for connection depth
+ * @param selectedNodeId Selected node
+ * @param focusedNodeId Deprecated - kept for compatibility
  * @param connectionDepth Depth level for connection filtering
- * @param visibleNodes Currently visible nodes after all filtering (for proper depth view fitting)
+ * @param visibleNodes Currently visible nodes after all filtering
  */
 export function useViewportManager(
   searchTerm: string,
   selectedNodeId: string | null,
-  focusedNodeId: string | null,
+  _focusedNodeId: string | null, // Deprecated - kept for compatibility
   connectionDepth: number | null,
   visibleNodes?: Node[]
 ) {
@@ -181,7 +180,6 @@ export function useViewportManager(
   const previousState = useRef({
     searchTerm: '',
     selectedNodeId: null as string | null,
-    focusedNodeId: null as string | null,
     connectionDepth: null as number | null
   });
   
@@ -190,11 +188,10 @@ export function useViewportManager(
    * Higher number = higher priority
    */
   const getCurrentPriority = useCallback(() => {
-    if (selectedNodeId) return 4; // Highest: specifically selected node
-    if (searchTerm && searchTerm.trim()) return 3; // High: search results
-    if (focusedNodeId && connectionDepth) return 2; // Medium: focused connections
+    if (selectedNodeId) return 3; // Highest: selected node
+    if (searchTerm && searchTerm.trim()) return 2; // High: search results
     return 1; // Lowest: all visible nodes
-  }, [selectedNodeId, searchTerm, focusedNodeId, connectionDepth]);
+  }, [selectedNodeId, searchTerm]);
   
   /**
    * Execute viewport change with smooth transitions
@@ -204,7 +201,7 @@ export function useViewportManager(
     
     setTimeout(() => {
       switch (priority) {
-        case 4: // Selected specific node
+        case 3: // Selected node
           if (selectedNodeId) {
             if (import.meta.env.DEV) {
               console.debug('[ViewportManager] Focusing on selected node:', selectedNodeId);
@@ -213,7 +210,7 @@ export function useViewportManager(
           }
           break;
           
-        case 3: // Search results
+        case 2: // Search results
           if (searchTerm?.trim()) {
             if (import.meta.env.DEV) {
               console.debug('[ViewportManager] Focusing on search results:', searchTerm);
@@ -222,32 +219,21 @@ export function useViewportManager(
           }
           break;
           
-        case 2: // Focused connections
-          if (focusedNodeId && visibleNodes && visibleNodes.length > 0) {
-            if (import.meta.env.DEV) {
-              console.debug('[ViewportManager] Focusing on connections for node:', focusedNodeId, 'with', visibleNodes.length, 'visible nodes');
-            }
-            // Fit to all visible nodes when connection depth is active
-            fitToNodes(visibleNodes.map(n => n.id), { padding: 0.3, duration: 600 });
-          } else if (focusedNodeId) {
-            // Fallback to just the focused node if visibleNodes not provided
-            if (import.meta.env.DEV) {
-              console.debug('[ViewportManager] Focusing on single node (fallback):', focusedNodeId);
-            }
-            fitToNodes([focusedNodeId], { padding: 0.3, duration: 600 });
-          }
-          break;
-          
-        case 1: // All nodes
+        case 1: // All visible nodes
         default:
           if (import.meta.env.DEV) {
             console.debug('[ViewportManager] Fitting all visible nodes');
           }
-          zoomToFit();
+          // If we have specific visible nodes, fit to them
+          if (visibleNodes && visibleNodes.length > 0) {
+            fitToNodes(visibleNodes.map(n => n.id), { padding: 0.3, duration: 600 });
+          } else {
+            zoomToFit();
+          }
           break;
       }
     }, delay);
-  }, [selectedNodeId, searchTerm, focusedNodeId, visibleNodes, fitToSearchResults, fitToNodes, zoomToFit]);
+  }, [selectedNodeId, searchTerm, visibleNodes, fitToSearchResults, fitToNodes, zoomToFit]);
   
   // Performance optimization: throttle rapid successive changes
   const throttleRef = useRef<NodeJS.Timeout | null>(null);
@@ -263,11 +249,10 @@ export function useViewportManager(
     // Check what changed
     const searchChanged = searchTerm !== prev.searchTerm;
     const selectedChanged = selectedNodeId !== prev.selectedNodeId;
-    const focusChanged = focusedNodeId !== prev.focusedNodeId;
     const depthChanged = connectionDepth !== prev.connectionDepth;
     
     // Performance optimization: Only trigger for meaningful changes
-    if (searchChanged || selectedChanged || focusChanged || depthChanged) {
+    if (searchChanged || selectedChanged || depthChanged) {
       // Edge case: Handle empty/whitespace-only search terms
       const normalizedSearch = searchTerm?.trim() || '';
       const normalizedPrevSearch = prev.searchTerm?.trim() || '';
@@ -285,12 +270,10 @@ export function useViewportManager(
         console.debug('[ViewportManager] State change detected:', {
           searchChanged,
           selectedChanged,
-          focusChanged, 
           depthChanged,
           currentPriority,
           searchTerm: normalizedSearch || 'none',
           selectedNodeId: selectedNodeId || 'none',
-          focusedNodeId: focusedNodeId || 'none',
           connectionDepth: connectionDepth || 'none'
         });
       }
@@ -323,11 +306,10 @@ export function useViewportManager(
       previousState.current = {
         searchTerm: normalizedSearch,
         selectedNodeId,
-        focusedNodeId,
         connectionDepth
       };
     }
-  }, [searchTerm, selectedNodeId, focusedNodeId, connectionDepth, getCurrentPriority, executeViewportChange]);
+  }, [searchTerm, selectedNodeId, connectionDepth, getCurrentPriority, executeViewportChange]);
   
   // Cleanup throttle timeout
   useEffect(() => {
diff --git a/src/lib/cache/CacheVersionManager.ts b/src/lib/cache/CacheVersionManager.ts
deleted file mode 100644
index 07a3876..0000000
--- a/src/lib/cache/CacheVersionManager.ts
+++ /dev/null
@@ -1,141 +0,0 @@
-/**
- * Frontend Cache Version Manager
- * 
- * Tracks cache versions from the backend and coordinates
- * invalidation with React Query when versions mismatch
- */
-
-import { QueryClient } from '@tanstack/react-query';
-// Logger removed in Phase 3
-
-
-export class CacheVersionManager {
-  private static instance: CacheVersionManager;
-  private currentVersion: string | null = null;
-  private entityVersions: Map<string, string> = new Map();
-  private queryClient: QueryClient | null = null;
-  
-  private constructor() {}
-  
-  static getInstance(): CacheVersionManager {
-    if (!CacheVersionManager.instance) {
-      CacheVersionManager.instance = new CacheVersionManager();
-    }
-    return CacheVersionManager.instance;
-  }
-  
-  /**
-   * Initialize with QueryClient
-   */
-  initialize(queryClient: QueryClient): void {
-    this.queryClient = queryClient;
-  }
-  
-  /**
-   * Process cache version from response headers
-   */
-  processResponseHeaders(headers: Headers): void {
-    const version = headers.get('X-Cache-Version');
-    const entityVersion = headers.get('X-Entity-Version');
-    const entityType = headers.get('X-Entity-Type');
-    
-    if (version && version !== this.currentVersion) {
-      console.debug(`[CacheVersionManager] Version changed: ${this.currentVersion} → ${version}`);
-      this.handleVersionChange(this.currentVersion, version);
-      this.currentVersion = version;
-    }
-    
-    if (entityVersion && entityType) {
-      const currentEntityVersion = this.entityVersions.get(entityType);
-      if (currentEntityVersion && currentEntityVersion !== entityVersion) {
-        console.debug(`[CacheVersionManager] Entity version changed for ${entityType}: ${currentEntityVersion} → ${entityVersion}`);
-        this.invalidateEntityQueries(entityType);
-      }
-      this.entityVersions.set(entityType, entityVersion);
-    }
-  }
-  
-  /**
-   * Handle global version change
-   */
-  private handleVersionChange(oldVersion: string | null, _newVersion: string): void {
-    if (!this.queryClient) return;
-    
-    // If this is not the first version we've seen, invalidate all queries
-    if (oldVersion !== null) {
-      console.debug('[CacheVersionManager] Invalidating all queries due to version change');
-      this.queryClient.invalidateQueries();
-    }
-  }
-  
-  /**
-   * Invalidate queries for specific entity type
-   */
-  private invalidateEntityQueries(entityType: string): void {
-    if (!this.queryClient) return;
-    
-    console.debug(`[CacheVersionManager] Invalidating queries for ${entityType}`);
-    this.queryClient.invalidateQueries({ queryKey: ['notion', entityType] });
-    
-    // Also invalidate related entity types
-    switch (entityType) {
-      case 'puzzles':
-        this.queryClient.invalidateQueries({ queryKey: ['notion', 'elements'] });
-        this.queryClient.invalidateQueries({ queryKey: ['notion', 'characters'] });
-        break;
-      case 'elements':
-        this.queryClient.invalidateQueries({ queryKey: ['notion', 'puzzles'] });
-        break;
-      case 'characters':
-        this.queryClient.invalidateQueries({ queryKey: ['notion', 'timeline'] });
-        break;
-    }
-  }
-  
-  /**
-   * Get current cache version
-   */
-  getCurrentVersion(): string | null {
-    return this.currentVersion;
-  }
-  
-  /**
-   * Get entity-specific version
-   */
-  getEntityVersion(entityType: string): string | null {
-    return this.entityVersions.get(entityType) || null;
-  }
-  
-  /**
-   * Check if version is valid
-   */
-  isVersionValid(version: string): boolean {
-    return version === this.currentVersion;
-  }
-  
-  /**
-   * Reset all versions (for logout/refresh)
-   */
-  reset(): void {
-    this.currentVersion = null;
-    this.entityVersions.clear();
-    if (this.queryClient) {
-      this.queryClient.invalidateQueries();
-    }
-  }
-  
-  /**
-   * Add version headers to request
-   */
-  getRequestHeaders(): Record<string, string> {
-    const headers: Record<string, string> = {};
-    
-    if (this.currentVersion) {
-      headers['X-Client-Cache-Version'] = this.currentVersion;
-    }
-    
-    return headers;
-  }
-}
-
-export const cacheVersionManager = CacheVersionManager.getInstance();
\ No newline at end of file
diff --git a/src/lib/cache/mutations.ts b/src/lib/cache/mutations.ts
deleted file mode 100644
index 37d31bd..0000000
--- a/src/lib/cache/mutations.ts
+++ /dev/null
@@ -1,414 +0,0 @@
-/**
- * Centralized Cache Mutation Utilities
- * 
- * Provides standardized patterns for cache updates following
- * the successful entityMutations.ts approach.
- * 
- * Key Principles:
- * - Surgical setQueryData updates instead of broad invalidation
- * - Explicit field-to-entity mapping for relationships
- * - Atomic updates for both list and individual caches
- * - Bidirectional relationship management
- */
-
-import type { QueryClient } from '@tanstack/react-query';
-import { queryKeys } from '@/lib/queryKeys';
-import type { 
-  Character, 
-  Element, 
-  Puzzle, 
-  TimelineEvent 
-} from '@/types/notion/app';
-
-export type EntityType = 'characters' | 'elements' | 'puzzles' | 'timeline';
-export type Entity = Character | Element | Puzzle | TimelineEvent;
-
-/**
- * Comprehensive field-to-entity type mapping.
- * Extends the pattern from entityMutations.ts to cover all relationships.
- */
-export const FIELD_TO_ENTITY_TYPE_MAP: Record<string, EntityType> = {
-  // Character relation fields (from Character interface)
-  ownedElementIds: 'elements',
-  associatedElementIds: 'elements',
-  characterPuzzleIds: 'puzzles',
-  eventIds: 'timeline',
-  connections: 'characters',       // Self-referential: other characters
-  
-  // Element relation fields (from Element interface)
-  ownerId: 'characters',          // Single character owner
-  containerId: 'elements',        // Self-referential: parent element
-  contentIds: 'elements',         // Self-referential: child elements
-  timelineEventId: 'timeline',    // Single timeline event
-  requiredForPuzzleIds: 'puzzles',
-  rewardedByPuzzleIds: 'puzzles',
-  containerPuzzleId: 'puzzles',   // Single puzzle container
-  associatedCharacterIds: 'characters', // From timeline rollup
-  
-  // Puzzle relation fields (from Puzzle interface)
-  puzzleElementIds: 'elements',
-  lockedItemId: 'elements',       // Single locked element
-  rewardIds: 'elements',
-  parentItemId: 'puzzles',        // Self-referential: parent puzzle
-  subPuzzleIds: 'puzzles',        // Self-referential: child puzzles
-  storyReveals: 'timeline',       // Timeline event IDs from rollup
-  // ownerId is already mapped above (from Element section)
-  
-  // Timeline relation fields (from TimelineEvent interface)
-  charactersInvolvedIds: 'characters',
-  memoryEvidenceIds: 'elements',
-};
-
-/**
- * Map of inverse relationships for bidirectional updates.
- * When field X on entity A points to entity B, this maps to field Y on entity B that points back to A.
- */
-export const INVERSE_RELATIONSHIP_MAP: Record<string, string> = {
-  // Character -> Element relationships
-  ownedElementIds: 'ownerId',        // Character owns Element -> Element has owner
-  associatedElementIds: 'associatedCharacterIds', // Character associated with Element
-  
-  // Element -> Character relationships
-  ownerId: 'ownedElementIds',        // Element owned by Character -> Character owns Element
-  associatedCharacterIds: 'associatedElementIds', // Element associated with Characters
-  
-  // Puzzle -> Element relationships  
-  puzzleElementIds: 'containerPuzzleId',  // Puzzle contains Elements -> Element in Puzzle
-  // Note: lockedByPuzzleId field doesn't exist in our schema, removed inverse mapping
-  rewardIds: 'rewardedByPuzzleIds',      // Puzzle rewards Elements -> Elements rewarded by Puzzle
-  
-  // Element -> Puzzle relationships
-  containerPuzzleId: 'puzzleElementIds',  // Element in Puzzle -> Puzzle contains Element
-  rewardedByPuzzleIds: 'rewardIds',      // Element rewarded by Puzzles -> Puzzles reward Element
-  
-  // Character -> Puzzle relationships
-  characterPuzzleIds: 'assignedCharacterIds', // Character has Puzzles -> Puzzles assigned to Character
-  
-  // Timeline -> Character relationships
-  charactersInvolvedIds: 'eventIds',     // Timeline involves Characters -> Characters in events
-  eventIds: 'charactersInvolvedIds',     // Characters in events -> Timeline involves Characters
-  
-  // Timeline -> Element relationships
-  memoryEvidenceIds: 'associatedTimelineIds', // Timeline has evidence -> Evidence in timeline
-  associatedTimelineIds: 'memoryEvidenceIds', // Evidence in timeline -> Timeline has evidence
-};
-
-/**
- * Get entity type from field key
- */
-export function getEntityTypeFromFieldKey(fieldKey: string): EntityType | null {
-  return FIELD_TO_ENTITY_TYPE_MAP[fieldKey] || null;
-}
-
-/**
- * Get query key for entity type
- */
-export function getQueryKeyForEntityType(entityType: EntityType): readonly string[] {
-  const keyMap = {
-    characters: queryKeys.characters(),
-    elements: queryKeys.elements(),
-    puzzles: queryKeys.puzzles(),
-    timeline: queryKeys.timeline(),
-  };
-  return keyMap[entityType];
-}
-
-/**
- * Update entity in both list and individual caches
- */
-export function updateEntityCaches<T extends Entity>(
-  queryClient: QueryClient,
-  entityType: EntityType,
-  entity: T
-): void {
-  const queryKey = getQueryKeyForEntityType(entityType);
-  
-  // Update list cache
-  queryClient.setQueryData(queryKey, (oldData: T[] | undefined) => {
-    if (!oldData) return [entity];
-    const index = oldData.findIndex(item => item.id === entity.id);
-    if (index === -1) return [...oldData, entity];
-    return oldData.map((item, i) => i === index ? entity : item);
-  });
-  
-  // Update individual cache
-  queryClient.setQueryData([...queryKey, entity.id], entity);
-}
-
-/**
- * Remove entity from caches
- */
-export function removeEntityFromCaches<T extends Entity>(
-  queryClient: QueryClient,
-  entityType: EntityType,
-  entityId: string
-): void {
-  const queryKey = getQueryKeyForEntityType(entityType);
-  
-  // Remove from list cache
-  queryClient.setQueryData(queryKey, (oldData: T[] | undefined) => {
-    if (!oldData) return [];
-    return oldData.filter(item => item.id !== entityId);
-  });
-  
-  // Remove individual cache
-  queryClient.removeQueries({ queryKey: [...queryKey, entityId] });
-}
-
-/**
- * Update related entities when a relationship field changes
- * Note: Currently marks related entities for refetch via invalidation
- * TODO: Implement surgical updates when we have full entity data
- */
-export function updateRelatedEntities(
-  queryClient: QueryClient,
-  _sourceEntityType: EntityType,
-  _sourceEntity: Entity,
-  updatedFields: Partial<Entity>
-): void {
-  // Track which entity types need updating
-  const relatedTypes = new Set<EntityType>();
-  
-  // Check each updated field for relationships
-  for (const field in updatedFields) {
-    const targetType = FIELD_TO_ENTITY_TYPE_MAP[field];
-    if (targetType) {
-      relatedTypes.add(targetType);
-    }
-  }
-  
-  // Update each related entity type
-  for (const entityType of relatedTypes) {
-    const queryKey = getQueryKeyForEntityType(entityType);
-    
-    // Update related entities with proper inverse relationships
-    queryClient.setQueryData(queryKey, (oldData: Entity[] | undefined) => {
-      if (!oldData) return oldData;
-      
-      return oldData.map(item => {
-        // Check each updated field for inverse relationships
-        for (const field in updatedFields) {
-          const inverseField = INVERSE_RELATIONSHIP_MAP[`${entityType}.${field}`] || 
-                               INVERSE_RELATIONSHIP_MAP[field];
-          
-          if (inverseField) {
-            const fieldValue = updatedFields[field as keyof Entity];
-            
-            // Handle array fields (many-to-many relationships)
-            if (Array.isArray(fieldValue)) {
-              // Check if this item is in the related IDs
-              if (fieldValue.includes(item.id)) {
-                // Add source entity to inverse field if not already present
-                const currentInverse = (item as any)[inverseField] || [];
-                if (Array.isArray(currentInverse) && !currentInverse.includes(_sourceEntity.id)) {
-                  return {
-                    ...item,
-                    [inverseField]: [...currentInverse, _sourceEntity.id]
-                  };
-                }
-              } else {
-                // Remove source entity from inverse field if present
-                const currentInverse = (item as any)[inverseField];
-                if (Array.isArray(currentInverse) && currentInverse.includes(_sourceEntity.id)) {
-                  return {
-                    ...item,
-                    [inverseField]: currentInverse.filter((id: string) => id !== _sourceEntity.id)
-                  };
-                }
-              }
-            }
-            // Handle single value fields (one-to-many relationships)
-            else if (typeof fieldValue === 'string' && fieldValue === item.id) {
-              return {
-                ...item,
-                [inverseField]: _sourceEntity.id
-              };
-            }
-          }
-        }
-        
-        return item;
-      });
-    });
-  }
-}
-
-/**
- * Handle relationship updates atomically
- */
-export function updateRelationship(
-  queryClient: QueryClient,
-  parentType: EntityType,
-  parentId: string,
-  fieldKey: string,
-  action: 'add' | 'remove',
-  childId: string
-): void {
-  const parentQueryKey = getQueryKeyForEntityType(parentType);
-  
-  // Update parent entity
-  queryClient.setQueryData(parentQueryKey, (oldData: Entity[] | undefined) => {
-    if (!oldData) return oldData;
-    return oldData.map(item => {
-      if (item.id !== parentId) return item;
-      
-      const currentValue = (item as any)[fieldKey] || [];
-      const updatedValue = action === 'add'
-        ? [...new Set([...currentValue, childId])]
-        : currentValue.filter((id: string) => id !== childId);
-      
-      return {
-        ...item,
-        [fieldKey]: updatedValue
-      };
-    });
-  });
-  
-  // Update individual parent cache
-  queryClient.setQueryData([...parentQueryKey, parentId], (oldParent: Entity | undefined) => {
-    if (!oldParent) return oldParent;
-    
-    const currentValue = (oldParent as any)[fieldKey] || [];
-    const updatedValue = action === 'add'
-      ? [...new Set([...currentValue, childId])]
-      : currentValue.filter((id: string) => id !== childId);
-    
-    return {
-      ...oldParent,
-      [fieldKey]: updatedValue
-    };
-  });
-  
-  // Update child entity for bidirectional relationships
-  const childType = getEntityTypeFromFieldKey(fieldKey);
-  const inverseFieldKey = INVERSE_RELATIONSHIP_MAP[fieldKey];
-  
-  if (childType && inverseFieldKey) {
-    const childQueryKey = getQueryKeyForEntityType(childType);
-    
-    // Update the inverse relationship on the child entity
-    queryClient.setQueryData([...childQueryKey, childId], (oldChild: Entity | undefined) => {
-      if (!oldChild) return oldChild;
-      
-      // Handle both array and single value inverse relationships
-      const currentInverseValue = (oldChild as any)[inverseFieldKey];
-      let updatedInverseValue;
-      
-      if (Array.isArray(currentInverseValue)) {
-        // Array field - add/remove parent ID
-        updatedInverseValue = action === 'add'
-          ? [...new Set([...currentInverseValue, parentId])]
-          : currentInverseValue.filter((id: string) => id !== parentId);
-      } else {
-        // Single value field - set or clear
-        updatedInverseValue = action === 'add' ? parentId : null;
-      }
-      
-      return {
-        ...oldChild,
-        [inverseFieldKey]: updatedInverseValue
-      };
-    });
-    
-    // Also update the child in the list cache
-    queryClient.setQueryData(childQueryKey, (oldList: Entity[] | undefined) => {
-      if (!oldList) return oldList;
-      
-      return oldList.map(item => {
-        if (item.id !== childId) return item;
-        
-        const currentInverseValue = (item as any)[inverseFieldKey];
-        let updatedInverseValue;
-        
-        if (Array.isArray(currentInverseValue)) {
-          updatedInverseValue = action === 'add'
-            ? [...new Set([...currentInverseValue, parentId])]
-            : currentInverseValue.filter((id: string) => id !== parentId);
-        } else {
-          updatedInverseValue = action === 'add' ? parentId : null;
-        }
-        
-        return {
-          ...item,
-          [inverseFieldKey]: updatedInverseValue
-        };
-      });
-    });
-  }
-}
-
-/**
- * Batch update multiple entities efficiently
- */
-export function batchUpdateEntities<T extends Entity>(
-  queryClient: QueryClient,
-  entityType: EntityType,
-  entities: T[]
-): void {
-  if (entities.length === 0) return;
-  
-  const queryKey = getQueryKeyForEntityType(entityType);
-  const entityMap = new Map(entities.map(e => [e.id, e]));
-  
-  // Update list cache
-  queryClient.setQueryData(queryKey, (oldData: T[] | undefined) => {
-    if (!oldData) return entities;
-    return oldData.map(item => entityMap.get(item.id) || item);
-  });
-  
-  // Update individual caches
-  for (const entity of entities) {
-    queryClient.setQueryData([...queryKey, entity.id], entity);
-  }
-}
-
-/**
- * Invalidate specific entity type queries
- * Only use when surgical updates aren't possible (e.g., pagination changes)
- */
-export function invalidateEntityType(
-  queryClient: QueryClient,
-  entityType: EntityType
-): void {
-  const queryKey = getQueryKeyForEntityType(entityType);
-  queryClient.invalidateQueries({ queryKey });
-}
-
-/**
- * Get related entity types that should be updated
- * when a specific entity type changes
- */
-export function getRelatedEntityTypes(
-  entityType: EntityType,
-  updatedFields?: string[]
-): Set<EntityType> {
-  const related = new Set<EntityType>();
-  
-  if (updatedFields) {
-    // Check specific fields for relationships
-    for (const field of updatedFields) {
-      const targetType = FIELD_TO_ENTITY_TYPE_MAP[field];
-      if (targetType) {
-        related.add(targetType);
-      }
-    }
-  } else {
-    // Get all possible related types for this entity
-    switch (entityType) {
-      case 'characters':
-        related.add('elements').add('puzzles').add('timeline');
-        break;
-      case 'elements':
-        related.add('characters').add('puzzles').add('timeline');
-        break;
-      case 'puzzles':
-        related.add('characters').add('elements').add('puzzles'); // self-referential
-        break;
-      case 'timeline':
-        related.add('characters').add('elements').add('puzzles');
-        break;
-    }
-  }
-  
-  return related;
-}
\ No newline at end of file
diff --git a/src/lib/graph/__tests__/relationships.test.ts b/src/lib/graph/__tests__/relationships.test.ts
deleted file mode 100644
index 63fd7d8..0000000
--- a/src/lib/graph/__tests__/relationships.test.ts
+++ /dev/null
@@ -1,350 +0,0 @@
-/**
- * Tests for Relationship Resolution
- */
-
-import { describe, it, expect, vi } from 'vitest';
-import {
-  buildLookupMaps,
-  createOwnershipEdges,
-  createRequirementEdges,
-  createRewardEdges,
-  createTimelineEdges,
-  createContainerEdges,
-  resolveAllRelationships,
-  filterEdgesByType,
-  getConnectedEdges,
-  calculateConnectivity,
-} from '../relationships';
-import type { Character, Element, Puzzle, TimelineEvent } from '@/types/notion/app';
-
-// Mock console methods
-const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
-const infoSpy = vi.spyOn(console, 'info').mockImplementation(() => {});
-
-describe('Relationship Resolution', () => {
-  afterEach(() => {
-    consoleSpy.mockClear();
-    infoSpy.mockClear();
-  });
-
-  // Mock data creators
-  const createMockCharacter = (id: string): Character => ({
-    id,
-    name: `Character ${id}`,
-    type: 'Player',
-    tier: 'Core',
-    ownedElementIds: [],
-    associatedElementIds: [],
-    characterPuzzleIds: [],
-    eventIds: [],
-    connections: [],
-    primaryAction: '',
-    characterLogline: '',
-    overview: '',
-    emotionTowardsCEO: '',
-  });
-
-  const createMockElement = (id: string): Element => ({
-    id,
-    name: `Element ${id}`,
-    descriptionText: '',
-    sfPatterns: {},
-    basicType: 'Prop',
-    ownerId: undefined,
-    containerId: undefined,
-    contentIds: [],
-    timelineEventId: undefined,
-    status: 'Done',
-    firstAvailable: null,
-    requiredForPuzzleIds: [],
-    rewardedByPuzzleIds: [],
-    containerPuzzleId: undefined,
-    narrativeThreads: [],
-    associatedCharacterIds: [],
-    puzzleChain: [],
-    productionNotes: '',
-    filesMedia: [],
-    contentLink: undefined,
-    isContainer: false,
-  });
-
-  const createMockPuzzle = (id: string): Puzzle => ({
-    id,
-    name: `Puzzle ${id}`,
-    descriptionSolution: '',
-    puzzleElementIds: [],
-    lockedItemId: undefined,
-    ownerId: undefined,
-    rewardIds: [],
-    parentItemId: undefined,
-    subPuzzleIds: [],
-    storyReveals: [],
-    timing: [],
-    narrativeThreads: [],
-    assetLink: undefined,
-  });
-
-  const createMockTimeline = (id: string): TimelineEvent => ({
-    id,
-    name: `Event ${id}`,
-    description: `Event ${id}`,
-    date: '2024-01-01T00:00:00Z',
-    charactersInvolvedIds: [],
-    memoryEvidenceIds: [],
-    memTypes: [],
-    notes: '',
-    lastEditedTime: '2024-01-01T00:00:00Z',
-  });
-
-  describe('buildLookupMaps', () => {
-    it('should create lookup maps for all entity types', () => {
-      const characters = [createMockCharacter('c1'), createMockCharacter('c2')];
-      const elements = [createMockElement('e1'), createMockElement('e2')];
-      const puzzles = [createMockPuzzle('p1'), createMockPuzzle('p2')];
-      const timeline = [createMockTimeline('t1'), createMockTimeline('t2')];
-
-      const maps = buildLookupMaps(characters, elements, puzzles, timeline);
-
-      expect(maps.characters.size).toBe(2);
-      expect(maps.elements.size).toBe(2);
-      expect(maps.puzzles.size).toBe(2);
-      expect(maps.timeline.size).toBe(2);
-
-      expect(maps.characters.get('c1')?.name).toBe('Character c1');
-      expect(maps.elements.get('e1')?.name).toBe('Element e1');
-      expect(maps.puzzles.get('p1')?.name).toBe('Puzzle p1');
-      expect(maps.timeline.get('t1')?.description).toBe('Event t1');
-    });
-  });
-
-  describe('createOwnershipEdges', () => {
-    it('should create ownership edges between characters and elements', () => {
-      const characters = [createMockCharacter('c1')];
-      const elements = [
-        { ...createMockElement('e1'), ownerId: 'c1' },
-        { ...createMockElement('e2'), ownerId: 'c1' },
-        createMockElement('e3'), // No owner
-      ];
-
-      const lookupMaps = buildLookupMaps(characters, [], [], []);
-      const edges = createOwnershipEdges(elements, lookupMaps);
-
-      expect(edges).toHaveLength(2);
-      expect(edges[0]?.source).toBe('c1');
-      expect(edges[0]?.target).toBe('e1');
-      expect(edges[0]?.data?.relationshipType).toBe('ownership');
-      expect(edges[1]?.source).toBe('c1');
-      expect(edges[1]?.target).toBe('e2');
-    });
-
-
-    it('should apply stronger weight for Core tier owners', () => {
-      const characters = [
-        { ...createMockCharacter('c1'), tier: 'Core' as const },
-        { ...createMockCharacter('c2'), tier: 'Secondary' as const },
-      ];
-      const elements = [
-        { ...createMockElement('e1'), ownerId: 'c1' },
-        { ...createMockElement('e2'), ownerId: 'c2' },
-      ];
-
-      const lookupMaps = buildLookupMaps(characters, elements, [], []);
-      const edges = createOwnershipEdges(elements, lookupMaps);
-
-      // Strength is not set in current implementation - tier-based weighting was removed
-      expect(edges[0]?.data?.relationshipType).toBe('ownership');
-      expect(edges[1]?.data?.relationshipType).toBe('ownership');
-    });
-  });
-
-  describe('createRequirementEdges', () => {
-    it('should create requirement edges between puzzles and elements', () => {
-      const elements = [createMockElement('e1'), createMockElement('e2')];
-      const puzzles = [
-        { ...createMockPuzzle('p1'), puzzleElementIds: ['e1', 'e2'] },
-      ];
-
-      const lookupMaps = buildLookupMaps([], elements, puzzles, []);
-      const edges = createRequirementEdges(puzzles, lookupMaps);
-
-      expect(edges).toHaveLength(2);
-      expect(edges[0]?.source).toBe('e1');  // Element flows INTO puzzle
-      expect(edges[0]?.target).toBe('p1');  // Puzzle receives the element
-      expect(edges[0]?.data?.relationshipType).toBe('requirement');
-      expect(edges[1]?.source).toBe('e2');
-      expect(edges[1]?.target).toBe('p1');
-    });
-
-  });
-
-  describe('createRewardEdges', () => {
-    it('should create reward edges between puzzles and reward elements', () => {
-      const elements = [createMockElement('e1'), createMockElement('e2')];
-      const puzzles = [
-        { ...createMockPuzzle('p1'), rewardIds: ['e1', 'e2'] },
-      ];
-
-      const lookupMaps = buildLookupMaps([], elements, puzzles, []);
-      const edges = createRewardEdges(puzzles, lookupMaps);
-
-      expect(edges).toHaveLength(2);
-      expect(edges[0]?.source).toBe('p1');
-      expect(edges[0]?.target).toBe('e1');
-      expect(edges[0]?.data?.relationshipType).toBe('reward');
-      expect(edges[0]?.label).toBe('reward'); // EDGE_STYLES uses 'reward' label
-      expect(edges[0]?.animated).toBe(true);
-    });
-  });
-
-  describe('createTimelineEdges', () => {
-    it('should create timeline edges between elements and timeline events', () => {
-      const timeline = [createMockTimeline('t1')];
-      const elements = [
-        { ...createMockElement('e1'), timelineEventId: 't1' },
-      ];
-
-      const lookupMaps = buildLookupMaps([], elements, [], timeline);
-      const edges = createTimelineEdges(elements, lookupMaps);
-
-      expect(edges).toHaveLength(1);
-      expect(edges[0]?.source).toBe('e1');
-      expect(edges[0]?.target).toBe('t1');
-      expect(edges[0]?.data?.relationshipType).toBe('timeline');
-      expect(edges[0]?.label).toBeUndefined(); // EDGE_STYLES for timeline has no label
-    });
-  });
-
-
-
-  describe('createContainerEdges', () => {
-    it('should create container edges between elements', () => {
-      const elements = [
-        { ...createMockElement('e1'), contentIds: ['e2', 'e3'] },
-        createMockElement('e2'),
-        createMockElement('e3'),
-      ];
-
-      const lookupMaps = buildLookupMaps([], elements, [], []);
-      const edges = createContainerEdges(elements, lookupMaps);
-
-      expect(edges).toHaveLength(2);
-      expect(edges[0]?.source).toBe('e1');
-      expect(edges[0]?.target).toBe('e2');
-      expect(edges[0]?.data?.relationshipType).toBe('container');
-      expect(edges[1]?.source).toBe('e1');
-      expect(edges[1]?.target).toBe('e3');
-    });
-  });
-
-  describe('resolveAllRelationships', () => {
-    it('should create all relationship types', () => {
-      const characters = [createMockCharacter('c1')];
-      const elements = [
-        { ...createMockElement('e1'), ownerId: 'c1', timelineEventId: 't1' },
-        { ...createMockElement('e2'), contentIds: ['e3'] },
-        createMockElement('e3'),
-      ];
-      const puzzles = [
-        { 
-          ...createMockPuzzle('p1'), 
-          puzzleElementIds: ['e1'],
-          rewardIds: ['e2'],
-          subPuzzleIds: ['p2'],
-        },
-        createMockPuzzle('p2'),
-      ];
-      const timeline = [createMockTimeline('t1')];
-
-      const edges = resolveAllRelationships(characters, elements, puzzles, timeline);
-
-      // Should have: 1 ownership + 1 requirement + 1 reward + 1 timeline + 1 container (chain removed)
-      // Note: EdgeBuilder may deduplicate or optimize edges
-      expect(edges.length).toBeGreaterThanOrEqual(4);
-
-      const edgeTypes = new Set(edges.map(e => e.data?.relationshipType));
-      expect(edgeTypes.has('ownership')).toBe(true);
-      expect(edgeTypes.has('requirement')).toBe(true);
-      expect(edgeTypes.has('reward')).toBe(true);
-      expect(edgeTypes.has('timeline')).toBe(true);
-      expect(edgeTypes.has('container')).toBe(true);
-      // Chain edges have been removed - verify they don't exist
-      expect(Array.from(edgeTypes)).not.toContain('chain');
-    });
-
-    it('should remove duplicate edges', () => {
-      // If somehow the same edge is created twice, it should be deduplicated
-      const elements = [
-        { ...createMockElement('e1'), ownerId: 'c1' },
-      ];
-      const characters = [createMockCharacter('c1')];
-
-      const edges = resolveAllRelationships(characters, elements, [], []);
-
-      // Should only have 1 ownership edge, not duplicates
-      const uniqueIds = new Set(edges.map(e => e.id));
-      expect(uniqueIds.size).toBe(edges.length);
-    });
-
-  });
-
-  describe('filterEdgesByType', () => {
-    it('should filter edges by relationship type', () => {
-      const edges = [
-        { id: '1', source: 'a', target: 'b', data: { relationshipType: 'ownership' } },
-        { id: '2', source: 'c', target: 'd', data: { relationshipType: 'requirement' } },
-        { id: '3', source: 'e', target: 'f', data: { relationshipType: 'ownership' } },
-      ] as any;
-
-      const filtered = filterEdgesByType(edges, ['ownership']);
-      expect(filtered).toHaveLength(2);
-      expect(filtered.every(e => e.data?.relationshipType === 'ownership')).toBe(true);
-    });
-
-    it('should handle multiple types', () => {
-      const edges = [
-        { id: '1', source: 'a', target: 'b', data: { relationshipType: 'ownership' } },
-        { id: '2', source: 'c', target: 'd', data: { relationshipType: 'requirement' } },
-        { id: '3', source: 'e', target: 'f', data: { relationshipType: 'reward' } },
-      ] as any;
-
-      const filtered = filterEdgesByType(edges, ['ownership', 'reward']);
-      expect(filtered).toHaveLength(2);
-      expect(filtered.map(e => e.data?.relationshipType)).toEqual(['ownership', 'reward']);
-    });
-  });
-
-  describe('getConnectedEdges', () => {
-    it('should find incoming and outgoing edges for a node', () => {
-      const edges = [
-        { id: '1', source: 'a', target: 'b' },
-        { id: '2', source: 'b', target: 'c' },
-        { id: '3', source: 'd', target: 'b' },
-        { id: '4', source: 'b', target: 'e' },
-      ] as any;
-
-      const connected = getConnectedEdges('b', edges);
-
-      expect(connected.incoming).toHaveLength(2); // edges 1 and 3
-      expect(connected.incoming.map(e => e.id)).toEqual(['1', '3']);
-
-      expect(connected.outgoing).toHaveLength(2); // edges 2 and 4
-      expect(connected.outgoing.map(e => e.id)).toEqual(['2', '4']);
-    });
-  });
-
-  describe('calculateConnectivity', () => {
-    it('should calculate total connectivity score', () => {
-      const edges = [
-        { id: '1', source: 'a', target: 'b' },
-        { id: '2', source: 'b', target: 'c' },
-        { id: '3', source: 'd', target: 'b' },
-      ] as any;
-
-      expect(calculateConnectivity('a', edges)).toBe(1); // 1 outgoing
-      expect(calculateConnectivity('b', edges)).toBe(3); // 1 incoming + 1 outgoing + 1 incoming
-      expect(calculateConnectivity('c', edges)).toBe(1); // 1 incoming
-      expect(calculateConnectivity('d', edges)).toBe(1); // 1 outgoing
-      expect(calculateConnectivity('e', edges)).toBe(0); // Not connected
-    });
-  });
-});
\ No newline at end of file
diff --git a/src/lib/graph/filtering.ts b/src/lib/graph/filtering.ts
index 89d2149..14f94b2 100644
--- a/src/lib/graph/filtering.ts
+++ b/src/lib/graph/filtering.ts
@@ -39,44 +39,37 @@ export function getNodesWithinDepth(
 }
 
 /**
- * Determine which nodes should be visible based on filter mode.
- * Consolidates all filter mode logic into a single pure function.
+ * Determine which nodes should be visible based on selection and connection depth.
+ * Simplified logic without filter modes.
  */
 export function getVisibleNodeIds(
-  mode: 'pure' | 'connected' | 'focused',
   filteredNodeIds: Set<string>,
   edges: Edge[],
-  focusNodeId: string | null,
-  connectionDepth: number | null,
-  respectFilters: boolean
+  selectedNodeId: string | null,
+  connectionDepth: number
 ): Set<string> {
-  // Pure mode: only show filtered nodes
-  if (mode === 'pure' || !connectionDepth || connectionDepth <= 0) {
+  // No connection depth? Just show filtered nodes
+  if (!connectionDepth || connectionDepth === 0) {
     return filteredNodeIds;
   }
   
-  // Focus mode: show N hops from focused node
-  if (mode === 'focused' && focusNodeId) {
-    const edgesToUse = respectFilters 
-      ? edges.filter(e => filteredNodeIds.has(e.source) && filteredNodeIds.has(e.target))
-      : edges;
-    return getNodesWithinDepth(focusNodeId, edgesToUse, connectionDepth);
+  // Node selected? Show connections from that node only
+  if (selectedNodeId && filteredNodeIds.has(selectedNodeId)) {
+    // Use all edges to find connections (not just filtered edges)
+    // This ensures we can see the full neighborhood of the selected node
+    return getNodesWithinDepth(selectedNodeId, edges, connectionDepth);
   }
   
-  // Connected mode: show filtered nodes + N hops from each
-  if (mode === 'connected') {
-    const connectedIds = new Set(filteredNodeIds);
-    const baseFilteredEdges = edges.filter(
-      e => filteredNodeIds.has(e.source) && filteredNodeIds.has(e.target)
-    );
-    
-    for (const nodeId of filteredNodeIds) {
-      const nodesFromStart = getNodesWithinDepth(nodeId, baseFilteredEdges, connectionDepth);
-      nodesFromStart.forEach(id => connectedIds.add(id));
-    }
-    return connectedIds;
+  // No selection? Show connections from ALL filtered nodes
+  const connectedIds = new Set(filteredNodeIds);
+  const baseFilteredEdges = edges.filter(
+    e => filteredNodeIds.has(e.source) && filteredNodeIds.has(e.target)
+  );
+  
+  for (const nodeId of filteredNodeIds) {
+    const connections = getNodesWithinDepth(nodeId, baseFilteredEdges, connectionDepth);
+    connections.forEach(id => connectedIds.add(id));
   }
   
-  // Default fallback
-  return filteredNodeIds;
+  return connectedIds;
 }
\ No newline at end of file
diff --git a/src/lib/graph/index.ts b/src/lib/graph/index.ts
index 2b93c95..5ed25f3 100644
--- a/src/lib/graph/index.ts
+++ b/src/lib/graph/index.ts
@@ -40,7 +40,7 @@ export {
 
 // Import and re-export existing utilities
 export { LAYOUT_PRESETS } from './layouts';
-export { filterEdgesByType, getConnectedEdges, calculateConnectivity } from './relationships';
+// Relationship utilities now handled server-side
 export { hasError, isEntityType as isEntity } from './guards';
 
 // Removed unused utility functions - direct implementations are used instead
diff --git a/src/lib/graph/nodeCreators.ts b/src/lib/graph/nodeCreators.ts
index 8af3eb1..3126245 100644
--- a/src/lib/graph/nodeCreators.ts
+++ b/src/lib/graph/nodeCreators.ts
@@ -259,7 +259,7 @@ export function createAllNodes(
   puzzleSelectedActs: Set<string>,
   elementBasicTypes: Set<string>,
   elementStatus: Set<string>,
-  // Note: connectionDepth, focusedNodeId, filterMode, focusRespectFilters
+  // Note: connectionDepth and selectedNodeId
   // are used for filtering AFTER node creation in useGraphLayout, not here
   viewConfig: { filters: { entityTypes?: string[] } }
 ): GraphNode[] {
diff --git a/src/lib/graph/relationships.ts b/src/lib/graph/relationships.ts
deleted file mode 100644
index 2c8637e..0000000
--- a/src/lib/graph/relationships.ts
+++ /dev/null
@@ -1,1187 +0,0 @@
-/**
- * Professional relationship resolution system for ALNRetool graph construction.
- * 
- * Provides comprehensive edge creation and relationship processing for "About Last Night"
- * murder mystery investigation networks, handling complex entity relationships with
- * graceful error handling, placeholder node generation, and advanced edge weighting.
- * 
- * **Core Responsibilities:**
- * - **Entity Relationship Mapping**: Convert Notion entity relationships into graph edges
- * - **Lookup Map Construction**: Efficient O(1) entity resolution through Map structures
- * - **Placeholder Generation**: Create visual indicators for missing/broken relationships
- * - **Edge Type Management**: Support for ownership, requirement, reward, timeline, container relationships
- * - **Backward Compatibility**: Legacy adapter functions for existing graph building workflows
- * - **Advanced Weighting**: Integration with EdgeBuilder for sophisticated edge importance calculation
- * 
- * **Relationship Type System:**
- * - **Ownership**: Character → Element (who owns what evidence/items)
- * - **Requirement**: Puzzle → Element (what evidence puzzles need)
- * - **Reward**: Puzzle → Element (what evidence puzzles provide)
- * - **Timeline**: Element → TimelineEvent (evidence reveals timeline information)
- * - **Container**: Element → Element (items contained within other items)
- * 
- * **Architecture Benefits:**
- * - **Efficient Lookup**: O(1) entity resolution through pre-built lookup maps
- * - **Error Resilience**: Graceful handling of missing entities with placeholder nodes
- * - **Visual Debugging**: Red-styled placeholder nodes highlight data integrity issues
- * - **Modular Design**: Separate functions for each relationship type enable targeted processing
- * - **Backward Compatibility**: Legacy adapter functions maintain existing API contracts
- * 
- * **Investigation Integration:**
- * - Character ownership analysis for evidence tracking
- * - Puzzle dependency mapping for investigation planning
- * - Timeline reconstruction through evidence-event connections
- * - Evidence container relationships for item organization
- * - Missing entity detection for data quality assurance
- * 
- * @example
- * ```typescript
- * // Build efficient lookup maps for relationship resolution
- * const lookupMaps = buildLookupMaps(characters, elements, puzzles, timeline);
- * 
- * // Create comprehensive relationship network
- * const ownershipEdges = createOwnershipEdges(elements, lookupMaps);
- * const requirementEdges = createRequirementEdges(puzzles, lookupMaps);
- * const rewardEdges = createRewardEdges(puzzles, lookupMaps);
- * const timelineEdges = createTimelineEdges(elements, lookupMaps);
- * const containerEdges = createContainerEdges(elements, lookupMaps);
- * 
- * // Combine all relationship types
- * const allEdges = [
- *   ...ownershipEdges,
- *   ...requirementEdges, 
- *   ...rewardEdges,
- *   ...timelineEdges,
- *   ...containerEdges
- * ];
- * 
- * // Handle missing entities with placeholders
- * const missingCharacter = createPlaceholderNode(
- *   'missing-suspect-id',
- *   'character',
- *   'witness-statement-001'
- * );
- * ```
- * 
- * @see {@link EdgeBuilder} For advanced edge weighting and style configuration
- * @see {@link EntityLookupMaps} For lookup map structure definitions
- * @see {@link PlaceholderNodeData} For placeholder node data interface
- * 
- * @author ALNRetool Development Team
- * @since 1.0.0
- * @module relationships
- */
-
-import type { 
-  Character, 
-  Element, 
-  Puzzle, 
-  TimelineEvent 
-} from '@/types/notion/app';
-import type { 
-  GraphEdge, 
-  EntityLookupMaps, 
-  RelationshipType,
-  EntityType
-} from './types';
-import { createEdge } from './edges';
-
-/**
- * Stable relationship type constants to prevent unnecessary re-renders
- * from string literal recreation
- */
-export const RELATIONSHIP_TYPES = {
-  OWNERSHIP: 'ownership',
-  REQUIREMENT: 'requirement',
-  REWARD: 'reward',
-  TIMELINE: 'timeline',
-  CONTAINER: 'container',
-  RELATIONSHIP: 'relationship',
-  CONNECTION: 'connection',
-  PLACEHOLDER: 'placeholder',
-} as const;
-
-// ============================================================================
-// Lookup Map Builders
-// ============================================================================
-
-/**
- * Entity lookup maps for efficient ID resolution (defined in types.ts)
- */
-export type { EntityLookupMaps } from './types';
-
-/**
- * Build comprehensive lookup maps for efficient O(1) entity ID resolution.
- * 
- * Creates optimized Map structures for each entity type within the murder mystery
- * investigation system, enabling fast relationship resolution and entity lookup
- * during graph construction and relationship processing workflows.
- * 
- * **Lookup Map Benefits:**
- * - **O(1) Access Time**: Direct Map lookup vs O(n) array searching
- * - **Memory Efficient**: Single Map instance per entity type
- * - **Type Safety**: Strongly typed Maps for each entity category
- * - **Relationship Resolution**: Fast entity existence checking and retrieval
- * - **Error Prevention**: Enables missing entity detection and placeholder creation
- * 
- * **Entity Type Coverage:**
- * - **Characters**: Suspects, witnesses, and key investigation figures
- * - **Elements**: Evidence, story items, and investigation clues
- * - **Puzzles**: Investigation challenges and puzzle dependencies
- * - **Timeline**: Temporal events and alibi information
- * 
- * @param characters Array of character entities from Notion API
- * @param elements Array of element entities from Notion API
- * @param puzzles Array of puzzle entities from Notion API
- * @param timeline Array of timeline event entities from Notion API
- * @returns Optimized lookup maps for O(1) entity resolution
- * 
- * @complexity O(V) where V is total number of entities across all types
- * 
- * @example
- * ```typescript
- * // Build lookup maps from Notion API data
- * const lookupMaps = buildLookupMaps(
- *   charactersFromNotion,
- *   elementsFromNotion,
- *   puzzlesFromNotion,
- *   timelineFromNotion
- * );
- * 
- * // Fast O(1) entity lookup
- * const marcus = lookupMaps.characters.get('marcus-blackwood-id');
- * const keyEvidence = lookupMaps.elements.get('key-evidence-id');
- * const mainPuzzle = lookupMaps.puzzles.get('main-puzzle-id');
- * const alibiEvent = lookupMaps.timeline.get('alibi-event-id');
- * 
- * // Entity existence checking for relationship validation
- * const validateRelationship = (sourceId: string, targetId: string, entityType: string) => {
- *   const lookupMap = lookupMaps[entityType as keyof EntityLookupMaps];
- *   const targetExists = lookupMap.has(targetId);
- *   
- *   if (!targetExists) {
- *     // Missing entity - handle gracefully without warnings
- *     return false;
- *   }
- *   
- *   return true;
- * };
- * 
- * // Batch entity processing with lookup optimization
- * const processRelationships = (relationships: Array<{source: string, target: string}>) => {
- *   return relationships.map(rel => {
- *     const sourceEntity = lookupMaps.characters.get(rel.source);
- *     const targetEntity = lookupMaps.elements.get(rel.target);
- *     
- *     return sourceEntity && targetEntity ? 
- *       { valid: true, source: sourceEntity, target: targetEntity } :
- *       { valid: false, sourceId: rel.source, targetId: rel.target };
- *   });
- * };
- * ```
- * 
- * @see {@link EntityLookupMaps} For lookup map structure interface
- * @see {@link createPlaceholderNode} For handling missing entity references
- * 
- * @remarks
- * **Performance Characteristics:**
- * - Map construction: O(V) one-time cost for all entities
- * - Lookup operations: O(1) constant time for each entity resolution
- * - Memory usage: Efficient Map storage with direct entity references
- * - Suitable for large investigation networks with hundreds of entities
- * 
- * **Investigation Workflow Integration:**
- * - Essential preprocessing step before relationship edge creation
- * - Enables fast validation of entity references in Notion data
- * - Supports missing entity detection for data quality assurance
- * - Optimizes performance for complex murder mystery network analysis
- */
-export function buildLookupMaps(
-  characters: Character[],
-  elements: Element[],
-  puzzles: Puzzle[],
-  timeline: TimelineEvent[]
-): EntityLookupMaps {
-  return {
-    characters: new Map(characters.map(c => [c.id, c])),
-    elements: new Map(elements.map(e => [e.id, e])),
-    puzzles: new Map(puzzles.map(p => [p.id, p])),
-    timeline: new Map(timeline.map(t => [t.id, t])),
-  };
-}
-
-
-// ============================================================================
-// Edge Creation Functions
-// ============================================================================
-
-
-// ============================================================================
-// Ownership Edges (Character -> Element)
-// ============================================================================
-
-/**
- * Create ownership edges between characters and their owned elements in murder mystery investigation.
- * 
- * Establishes visual connections showing which characters own or control specific elements
- * (evidence, items, clues) within the investigation graph, enabling ownership tracking
- * and suspect-evidence relationship analysis for murder mystery investigation workflow.
- * 
- * **Ownership Relationship Types:**
- * - **Direct Ownership**: Characters who possess physical evidence or items
- * - **Control Relationships**: Characters with access to or influence over elements
- * - **Custodial Connections**: Characters responsible for specific investigation items
- * - **Property Links**: Characters with legal or practical ownership of story elements
- * 
- * **Edge Creation Strategy:**
- * - Uses EdgeBuilder for consistent edge data structure and metadata
- * - Validates character and element existence through lookup maps
- * - Creates placeholder nodes for missing entity references
- * - Applies backward compatibility transformation for legacy graph systems
- * 
- * @param elements Array of story elements that may be owned by characters
- * @param lookupMaps Entity lookup maps for O(1) entity resolution and validation
- * @returns Array of ownership edges connecting characters to owned elements
- * 
- * @complexity O(E * O) where E is elements count and O is average owners per element
- * 
- * @example
- * ```typescript
- * // Create ownership edges for investigation elements
- * const elements = await getElements();
- * const lookupMaps = buildLookupMaps(characters, elements, puzzles, timeline);
- * const ownershipEdges = createOwnershipEdges(elements, lookupMaps);
- * 
- * console.log('Ownership analysis:', {
- *   totalEdges: ownershipEdges.length,
- *   ownedElements: ownershipEdges.map(e => e.target),
- *   owningCharacters: [...new Set(ownershipEdges.map(e => e.source))]
- * });
- * 
- * // Filter edges by ownership strength
- * const strongOwnership = ownershipEdges.filter(edge => 
- *   edge.data.weight > 0.8
- * );
- * 
- * // Investigation ownership network analysis
- * const analyzeOwnership = (edges: GraphEdge[]) => {
- *   const ownershipNetwork = edges.reduce((network, edge) => {
- *     const owner = edge.source;
- *     if (!network[owner]) network[owner] = [];
- *     network[owner].push(edge.target);
- *     return network;
- *   }, {} as Record<string, string[]>);
- *   
- *   return Object.entries(ownershipNetwork).map(([character, ownedItems]) => ({
- *     characterId: character,
- *     ownedCount: ownedItems.length,
- *     ownedItems,
- *     suspicionLevel: ownedItems.length > 3 ? 'high' : 'normal'
- *   }));
- * };
- * ```
- * 
- * @see {@link EdgeBuilder} For edge creation with consistent data structure
- * @see {@link EntityLookupMaps} For entity resolution and validation
- * 
- * @remarks
- * **Backward Compatibility:**
- * - Transforms EdgeBuilder output to legacy GraphEdge format
- * - Flattens metadata into data structure for existing graph consumers
- * - Maintains relationshipType field for edge classification
- * - Preserves logging and debugging information for investigation analysis
- * 
- * **Investigation Workflow Integration:**
- * - Essential for suspect-evidence relationship tracking
- * - Enables ownership-based filtering and analysis in investigation interface
- * - Supports evidence chain visualization for murder mystery resolution
- * - Provides ownership strength metrics for investigation prioritization
- */
-export function createOwnershipEdges(
-  elements: Element[],
-  lookupMaps: EntityLookupMaps
-): GraphEdge[] {
-  const edges: GraphEdge[] = [];
-  
-  elements.forEach(element => {
-    if (!element.ownerId) return;
-    
-    // Check if owner exists
-    const owner = lookupMaps.characters.get(element.ownerId);
-    if (!owner) {
-      // Skip edge creation if owner doesn't exist
-      // This prevents console warnings and invalid edges
-      console.debug(`Skipping ownership edge for element "${element.name}" (${element.id}) - owner not found: ${element.ownerId}`);
-      return;
-    }
-    
-    const edge = createEdge(
-      element.ownerId,  // Character is source
-      element.id,       // Element is target
-      RELATIONSHIP_TYPES.OWNERSHIP
-    );
-    
-    if (edge) {
-      // Add metadata for backward compatibility
-      edge.data = {
-        ...edge.data,
-        relationshipType: RELATIONSHIP_TYPES.OWNERSHIP,
-      };
-      edges.push(edge as GraphEdge);
-    }
-  });
-  
-  console.info(`Created ${edges.length} ownership edges`);
-  return edges;
-}
-
-// ============================================================================
-// Requirement Edges (Puzzle -> Element)
-// ============================================================================
-
-/**
- * Create requirement edges between puzzles and required elements in murder mystery investigation.
- * 
- * Establishes dependency connections showing which elements (evidence, items, clues) are
- * required to solve specific investigation puzzles, enabling puzzle dependency tracking
- * and investigation progression analysis for murder mystery game mechanics.
- * 
- * **Requirement Dependency Types:**
- * - **Evidence Requirements**: Physical evidence needed to solve investigation challenges
- * - **Item Dependencies**: Story items required for puzzle interaction or completion
- * - **Clue Prerequisites**: Information clues necessary for puzzle understanding
- * - **Knowledge Gates**: Character knowledge required for puzzle access or solution
- * 
- * **Puzzle Dependency Analysis:**
- * - Creates directed edges from puzzles to required elements
- * - Validates element existence and creates placeholders for missing references
- * - Supports puzzle chain analysis and investigation progression tracking
- * - Enables dependency-based puzzle unlocking and investigation flow control
- * 
- * @param puzzles Array of investigation puzzles with element requirements
- * @param lookupMaps Entity lookup maps for O(1) element resolution and validation
- * @returns Array of requirement edges connecting puzzles to required elements
- * 
- * @complexity O(P * R) where P is puzzles count and R is average requirements per puzzle
- * 
- * @example
- * ```typescript
- * // Create requirement edges for investigation puzzles
- * const puzzles = await getPuzzles();
- * const lookupMaps = buildLookupMaps(characters, elements, puzzles, timeline);
- * const requirementEdges = createRequirementEdges(puzzles, lookupMaps);
- * 
- * console.log('Puzzle dependency analysis:', {
- *   totalEdges: requirementEdges.length,
- *   puzzlesWithRequirements: [...new Set(requirementEdges.map(e => e.source))].length,
- *   requiredElements: [...new Set(requirementEdges.map(e => e.target))]
- * });
- * 
- * // Analysis puzzle dependency chains
- * const analyzeDependencyChains = (edges: GraphEdge[]) => {
- *   const dependencyMap = edges.reduce((map, edge) => {
- *     const puzzleId = edge.source;
- *     if (!map[puzzleId]) map[puzzleId] = [];
- *     map[puzzleId].push(edge.target);
- *     return map;
- *   }, {} as Record<string, string[]>);
- *   
- *   return Object.entries(dependencyMap).map(([puzzleId, requirements]) => ({
- *     puzzleId,
- *     requirementCount: requirements.length,
- *     requirements,
- *     complexity: requirements.length > 2 ? 'complex' : 'simple',
- *     canProgress: requirements.every(reqId => 
- *       lookupMaps.elements.has(reqId) // All requirements available
- *     )
- *   }));
- * };
- * 
- * // Investigation progression tracking
- * const trackProgression = (completedElements: string[]) => {
- *   return requirementEdges.filter(edge => 
- *     completedElements.includes(edge.target)
- *   ).map(edge => edge.source); // Unlocked puzzles
- * };
- * ```
- * 
- * @see {@link EdgeBuilder} For consistent edge creation with metadata
- * @see {@link EntityLookupMaps} For element resolution and validation
- * @see {@link Puzzle} For puzzle structure with element requirements
- * 
- * @remarks
- * **Investigation Workflow Benefits:**
- * - Enables puzzle dependency visualization in investigation interface
- * - Supports investigation progression tracking and puzzle unlocking logic
- * - Facilitates dependency-based investigation guidance and hints
- * - Provides foundation for investigation complexity analysis and balancing
- * 
- * **Edge Data Structure:**
- * - relationshipType: 'requirement' for dependency identification
- * - Metadata includes requirement strength and puzzle context information
- * - Backward compatible with legacy graph processing systems
- * - Logging includes dependency count for investigation debugging
- */
-export function createRequirementEdges(
-  puzzles: Puzzle[],
-  lookupMaps: EntityLookupMaps
-): GraphEdge[] {
-  const edges: GraphEdge[] = [];
-  
-  puzzles.forEach(puzzle => {
-    if (!puzzle.puzzleElementIds || puzzle.puzzleElementIds.length === 0) return;
-    
-    puzzle.puzzleElementIds.forEach(elementId => {
-      // Check if element exists
-      const element = lookupMaps.elements.get(elementId);
-      if (!element) {
-        // Skip edge creation if element doesn't exist
-        // This prevents console warnings and invalid edges
-        return;
-      }
-      
-      const edge = createEdge(
-        elementId,  // Element is the source (flows into puzzle)
-        puzzle.id,  // Puzzle is the target (receives the element)
-        RELATIONSHIP_TYPES.REQUIREMENT
-      );
-      
-      if (edge) {
-        // Add metadata for backward compatibility
-        edge.data = {
-          ...edge.data,
-          relationshipType: RELATIONSHIP_TYPES.REQUIREMENT,
-        };
-        edges.push(edge as GraphEdge);
-      }
-    });
-  });
-  
-  console.info(`Created ${edges.length} requirement edges`);
-  return edges;
-}
-
-// ============================================================================
-// Reward Edges (Puzzle -> Element)
-// ============================================================================
-
-/**
- * Create reward edges between puzzles and reward elements in murder mystery investigation.
- * 
- * Establishes reward connections showing which elements (evidence, items, clues, information)
- * are unlocked or revealed upon successful completion of investigation puzzles, enabling
- * reward tracking and investigation progression visualization for murder mystery game mechanics.
- * 
- * **Reward Relationship Types:**
- * - **Evidence Rewards**: New physical evidence revealed through puzzle completion
- * - **Information Unlocks**: Clues or knowledge gained from solving investigation challenges
- * - **Item Rewards**: Story items or tools obtained through puzzle interaction
- * - **Access Grants**: Timeline events or character interactions unlocked by puzzle success
- * 
- * **Reward System Integration:**
- * - Creates directed edges from puzzles to reward elements
- * - Validates reward element existence and creates placeholders for missing rewards
- * - Supports investigation progression visualization and reward anticipation
- * - Enables reward-based motivation and investigation flow optimization
- * 
- * @param puzzles Array of investigation puzzles with reward elements
- * @param lookupMaps Entity lookup maps for O(1) reward element resolution and validation
- * @returns Array of reward edges connecting puzzles to unlocked reward elements
- * 
- * @complexity O(P * W) where P is puzzles count and W is average rewards per puzzle
- * 
- * @example
- * ```typescript
- * // Create reward edges for investigation puzzle system
- * const puzzles = await getPuzzles();
- * const lookupMaps = buildLookupMaps(characters, elements, puzzles, timeline);
- * const rewardEdges = createRewardEdges(puzzles, lookupMaps);
- * 
- * console.log('Puzzle reward analysis:', {
- *   totalEdges: rewardEdges.length,
- *   puzzlesWithRewards: [...new Set(rewardEdges.map(e => e.source))].length,
- *   availableRewards: [...new Set(rewardEdges.map(e => e.target))],
- *   averageRewardsPerPuzzle: rewardEdges.length / puzzles.length
- * });
- * 
- * // Analyze reward distribution and value
- * const analyzeRewardSystem = (edges: GraphEdge[]) => {
- *   const rewardMap = edges.reduce((map, edge) => {
- *     const puzzleId = edge.source;
- *     if (!map[puzzleId]) map[puzzleId] = [];
- *     map[puzzleId].push(edge.target);
- *     return map;
- *   }, {} as Record<string, string[]>);
- *   
- *   return Object.entries(rewardMap).map(([puzzleId, rewards]) => ({
- *     puzzleId,
- *     rewardCount: rewards.length,
- *     rewards,
- *     rewardValue: rewards.length > 1 ? 'high' : 'standard',
- *     motivationLevel: rewards.length * 10 // Simple reward motivation scoring
- *   }));
- * };
- * 
- * // Investigation motivation and progression tracking
- * const trackRewardProgression = (completedPuzzles: string[]) => {
- *   const unlockedRewards = rewardEdges
- *     .filter(edge => completedPuzzles.includes(edge.source))
- *     .map(edge => edge.target);
- *   
- *   return {
- *     totalUnlocked: unlockedRewards.length,
- *     unlockedRewards,
- *     progressionPercentage: (unlockedRewards.length / rewardEdges.length) * 100
- *   };
- * };
- * ```
- * 
- * @see {@link EdgeBuilder} For consistent reward edge creation with metadata
- * @see {@link EntityLookupMaps} For reward element resolution and validation
- * @see {@link Puzzle} For puzzle structure with reward element specifications
- * 
- * @remarks
- * **Investigation Motivation Design:**
- * - Reward edges provide visual motivation for puzzle completion
- * - Enables investigation reward system balancing and optimization
- * - Supports reward-based investigation guidance and player engagement
- * - Facilitates investigation progression feedback and achievement tracking
- * 
- * **Game Mechanics Integration:**
- * - Essential for murder mystery investigation progression systems
- * - Enables reward-based puzzle difficulty balancing and player motivation
- * - Supports investigation reward visualization and anticipation features
- * - Provides foundation for investigation achievement and progress tracking
- */
-export function createRewardEdges(
-  puzzles: Puzzle[],
-  lookupMaps: EntityLookupMaps
-): GraphEdge[] {
-  const edges: GraphEdge[] = [];
-  
-  puzzles.forEach(puzzle => {
-    if (!puzzle.rewardIds || puzzle.rewardIds.length === 0) return;
-    
-    
-    puzzle.rewardIds.forEach(elementId => {
-      // Check if element exists
-      const element = lookupMaps.elements.get(elementId);
-      if (!element) {
-        // Skip edge creation if element doesn't exist
-        // This prevents console warnings and invalid edges
-        return;
-      }
-      
-      // Removed console.log to prevent console spam during infinite loop
-      
-      const edge = createEdge(
-        puzzle.id,   // Puzzle is the source (provides the reward)
-        elementId,   // Element is the target (receives as reward)
-        RELATIONSHIP_TYPES.REWARD
-      );
-      
-      if (edge) {
-        // Add metadata for backward compatibility
-        edge.data = {
-          ...edge.data,
-          relationshipType: RELATIONSHIP_TYPES.REWARD,
-        };
-        edges.push(edge as GraphEdge);
-      }
-    });
-  });
-  
-  console.info(`Created ${edges.length} reward edges`);
-  return edges;
-}
-
-// ============================================================================
-// Timeline Edges (Element -> Timeline)
-// ============================================================================
-
-/**
- * Create timeline edges between elements and timeline events they reveal in murder mystery investigation.
- * 
- * Establishes temporal connections showing which story elements (evidence, items, clues) reveal
- * or unlock specific timeline events, enabling chronological investigation tracking and alibi
- * analysis for murder mystery investigation workflow and temporal reasoning.
- * 
- * **Timeline Revelation Types:**
- * - **Evidence Reveals**: Physical evidence that reveals specific events or alibis
- * - **Clue Connections**: Information clues that unlock timeline event details
- * - **Item Triggers**: Story items that reveal chronological information or event context
- * - **Character Testimonies**: Character-related elements that reveal timeline information
- * 
- * **Temporal Investigation Features:**
- * - Creates directed edges from elements to revealed timeline events
- * - Validates timeline event existence and creates placeholders for missing events
- * - Supports chronological investigation progression and alibi verification
- * - Enables temporal reasoning and investigation timeline reconstruction
- * 
- * @param elements Array of story elements that may reveal timeline information
- * @param lookupMaps Entity lookup maps for O(1) timeline event resolution and validation
- * @returns Array of timeline edges connecting elements to revealed timeline events
- * 
- * @complexity O(E * T) where E is elements count and T is average timeline events per element
- * 
- * @example
- * ```typescript
- * // Create timeline edges for temporal investigation analysis
- * const elements = await getElements();
- * const lookupMaps = buildLookupMaps(characters, elements, puzzles, timeline);
- * const timelineEdges = createTimelineEdges(elements, lookupMaps);
- * 
- * console.log('Timeline revelation analysis:', {
- *   totalEdges: timelineEdges.length,
- *   revealingElements: [...new Set(timelineEdges.map(e => e.source))].length,
- *   revealedEvents: [...new Set(timelineEdges.map(e => e.target))],
- *   averageEventsPerElement: timelineEdges.length / elements.length
- * });
- * 
- * // Analyze temporal investigation progression
- * const analyzeTimelineProgression = (edges: GraphEdge[]) => {
- *   const revelationMap = edges.reduce((map, edge) => {
- *     const elementId = edge.source;
- *     if (!map[elementId]) map[elementId] = [];
- *     map[elementId].push(edge.target);
- *     return map;
- *   }, {} as Record<string, string[]>);
- *   
- *   return Object.entries(revelationMap).map(([elementId, events]) => ({
- *     elementId,
- *     revealedEventCount: events.length,
- *     revealedEvents: events,
- *     temporalImportance: events.length > 1 ? 'high' : 'standard',
- *     investigationValue: events.length * 15 // Temporal evidence scoring
- *   }));
- * };
- * 
- * // Alibi verification and timeline reconstruction
- * const reconstructTimeline = (discoveredElements: string[]) => {
- *   const revealedEvents = timelineEdges
- *     .filter(edge => discoveredElements.includes(edge.source))
- *     .map(edge => edge.target);
- *   
- *   // Sort by timeline event dates for chronological reconstruction
- *   const chronologicalEvents = revealedEvents
- *     .map(eventId => lookupMaps.timeline.get(eventId))
- *     .filter(Boolean)
- *     .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
- *   
- *   return {
- *     totalRevealed: revealedEvents.length,
- *     chronologicalSequence: chronologicalEvents,
- *     timelineCompleteness: (revealedEvents.length / lookupMaps.timeline.size) * 100
- *   };
- * };
- * ```
- * 
- * @see {@link EdgeBuilder} For consistent timeline edge creation with temporal metadata
- * @see {@link EntityLookupMaps} For timeline event resolution and validation
- * @see {@link Element} For element structure with timeline revelation capabilities
- * @see {@link TimelineEvent} For timeline event structure and temporal information
- * 
- * @remarks
- * **Temporal Investigation Benefits:**
- * - Enables chronological investigation visualization and timeline reconstruction
- * - Supports alibi verification and temporal evidence analysis in murder mystery context
- * - Facilitates investigation timeline completion tracking and progress measurement
- * - Provides foundation for temporal reasoning and chronological investigation features
- * 
- * **Murder Mystery Integration:**
- * - Essential for alibi analysis and temporal evidence correlation
- * - Enables chronological investigation progression and timeline-based clue revelation
- * - Supports temporal investigation interface features and timeline visualization
- * - Provides temporal context for investigation decision-making and evidence evaluation
- */
-export function createTimelineEdges(
-  elements: Element[],
-  lookupMaps: EntityLookupMaps
-): GraphEdge[] {
-  const edges: GraphEdge[] = [];
-  
-  elements.forEach(element => {
-    if (!element.timelineEventId) return;
-    
-    // Check if timeline event exists
-    const timelineEvent = lookupMaps.timeline.get(element.timelineEventId);
-    if (!timelineEvent) {
-      // This is expected in filtered views where not all timeline events are included
-      console.debug(`Element ${element.name} references timeline event not in current view: ${element.timelineEventId}`);
-      return;
-    }
-    
-    const edge = createEdge(
-      element.id,
-      element.timelineEventId,
-      RELATIONSHIP_TYPES.TIMELINE
-    );
-    
-    if (edge) {
-      // Add metadata for backward compatibility
-      edge.data = {
-        ...edge.data,
-        relationshipType: RELATIONSHIP_TYPES.TIMELINE,
-      };
-      edges.push(edge as GraphEdge);
-    }
-  });
-  
-  console.info(`Created ${edges.length} timeline edges`);
-  return edges;
-}
-
-
-
-// ============================================================================
-// Container Edges (Element -> Element)
-// ============================================================================
-
-/**
- * Create container edges between elements and their contained sub-elements in murder mystery investigation.
- * 
- * Establishes containment relationships showing which story elements contain or hold other
- * elements within the investigation, enabling nested evidence tracking and container-based
- * investigation mechanics for murder mystery evidence organization and discovery.
- * 
- * **Container Relationship Types:**
- * - **Physical Containers**: Items that physically contain other evidence or clues
- * - **Information Containers**: Documents or records that contain sub-information elements
- * - **Nested Evidence**: Complex evidence items with internal component evidence
- * - **Collection Containers**: Evidence collections with individual component items
- * 
- * **Container Investigation Features:**
- * - Creates directed edges from container elements to contained elements
- * - Validates contained element existence and creates placeholders for missing contents
- * - Supports nested evidence exploration and container-based investigation progression
- * - Enables hierarchical evidence organization and container search mechanics
- * 
- * @param elements Array of story elements that may contain other elements
- * @param lookupMaps Entity lookup maps for O(1) contained element resolution and validation
- * @returns Array of container edges connecting container elements to contained elements
- * 
- * @complexity O(E * C) where E is elements count and C is average contained elements per container
- * 
- * @example
- * ```typescript
- * // Create container edges for nested evidence investigation
- * const elements = await getElements();
- * const lookupMaps = buildLookupMaps(characters, elements, puzzles, timeline);
- * const containerEdges = createContainerEdges(elements, lookupMaps);
- * 
- * console.log('Container relationship analysis:', {
- *   totalEdges: containerEdges.length,
- *   containerElements: [...new Set(containerEdges.map(e => e.source))].length,
- *   containedElements: [...new Set(containerEdges.map(e => e.target))],
- *   averageContentsPerContainer: containerEdges.length / elements.filter(e => e.containedElementIds?.length).length
- * });
- * 
- * // Analyze container hierarchy and nested evidence structure
- * const analyzeContainerHierarchy = (edges: GraphEdge[]) => {
- *   const containerMap = edges.reduce((map, edge) => {
- *     const containerId = edge.source;
- *     if (!map[containerId]) map[containerId] = [];
- *     map[containerId].push(edge.target);
- *     return map;
- *   }, {} as Record<string, string[]>);
- *   
- *   return Object.entries(containerMap).map(([containerId, contents]) => ({
- *     containerId,
- *     contentCount: contents.length,
- *     contents,
- *     containerComplexity: contents.length > 2 ? 'complex' : 'simple',
- *     investigationValue: contents.length * 5 // Container investigation scoring
- *   }));
- * };
- * 
- * // Container exploration and evidence discovery tracking
- * const trackContainerExploration = (exploredContainers: string[]) => {
- *   const discoveredContents = containerEdges
- *     .filter(edge => exploredContainers.includes(edge.source))
- *     .map(edge => edge.target);
- *   
- *   return {
- *     totalDiscovered: discoveredContents.length,
- *     discoveredContents,
- *     explorationCompleteness: (exploredContainers.length / [...new Set(containerEdges.map(e => e.source))].length) * 100
- *   };
- * };
- * ```
- * 
- * @see {@link EdgeBuilder} For consistent container edge creation with containment metadata
- * @see {@link EntityLookupMaps} For contained element resolution and validation
- * @see {@link Element} For element structure with containment capabilities
- * 
- * @remarks
- * **Investigation Mechanics Benefits:**
- * - Enables nested evidence exploration and container-based investigation features
- * - Supports hierarchical evidence organization and container search mechanics
- * - Facilitates investigation progression through container discovery and exploration
- * - Provides foundation for container-based evidence tracking and collection management
- * 
- * **Container Investigation Design:**
- * - Essential for murder mystery investigation with complex evidence hierarchies
- * - Enables container-based evidence discovery and nested investigation mechanics
- * - Supports investigation interface features for container exploration and content revelation
- * - Provides container-based evidence organization for investigation workflow optimization
- */
-export function createContainerEdges(
-  elements: Element[],
-  lookupMaps: EntityLookupMaps
-): GraphEdge[] {
-  const edges: GraphEdge[] = [];
-  
-  elements.forEach(element => {
-    if (!element.contentIds || element.contentIds.length === 0) return;
-    
-    element.contentIds.forEach(contentId => {
-      // Skip self-referential edges
-      if (element.id === contentId) {
-        // Self-referential edges are invalid and should be skipped
-        return;
-      }
-      
-      // Check if content element exists
-      const contentElement = lookupMaps.elements.get(contentId);
-      if (!contentElement) {
-        // Skip edge creation if content element doesn't exist
-        // This prevents console warnings and invalid edges
-        return;
-      }
-      
-      const edge = createEdge(
-        element.id,   // Container is source
-        contentId,    // Content element is target
-        RELATIONSHIP_TYPES.CONTAINER   // Now using proper constant
-      );
-      
-      if (edge) {
-        // Add metadata for container relationship
-        edge.data = {
-          ...edge.data,
-          relationshipType: RELATIONSHIP_TYPES.CONTAINER,
-        };
-        edges.push(edge);
-      }
-    });
-  });
-  
-  console.info(`Created ${edges.length} container edges`);
-  return edges;
-}
-
-// ============================================================================
-// Character Puzzle Edge Creation
-// ============================================================================
-
-/**
- * Create edges between characters and their associated puzzles.
- * 
- * Establishes connections showing which puzzles are directly associated with
- * specific characters in the murder mystery investigation.
- * 
- * @param characters Array of characters with puzzle associations
- * @param lookupMaps Entity lookup maps for O(1) puzzle resolution
- * @returns Array of character-puzzle edges
- */
-export function createCharacterPuzzleEdges(
-  characters: Character[],
-  lookupMaps: EntityLookupMaps
-): GraphEdge[] {
-  const edges: GraphEdge[] = [];
-  
-  characters.forEach(character => {
-    if (!character.characterPuzzleIds || character.characterPuzzleIds.length === 0) return;
-    
-    character.characterPuzzleIds.forEach(puzzleId => {
-      // Check if puzzle exists
-      const puzzle = lookupMaps.puzzles.get(puzzleId);
-      
-      if (puzzle) {
-        // Create character → puzzle edge
-        edges.push(createEdge(
-          character.id,
-          puzzleId,
-          RELATIONSHIP_TYPES.RELATIONSHIP,
-          undefined, // sourceNode
-          undefined, // targetNode
-          { weight: 2 } // Medium weight
-        ));
-      }
-      // Skip edge creation if puzzle doesn't exist (no warning needed)
-    });
-  });
-  
-  console.info(`Created ${edges.length} character-puzzle edges`);
-  if (edges.length > 0) {
-    console.debug('Character-puzzle edges:', edges.map(e => ({
-      from: characters.find(c => c.id === e.source)?.name || e.source,
-      to: lookupMaps.puzzles.get(e.target)?.name || e.target
-    })));
-  }
-  return edges;
-}
-
-// ============================================================================
-// Character Connection Edge Creation
-// ============================================================================
-
-/**
- * Create edges between characters who share timeline connections.
- * 
- * Establishes bidirectional connections between characters who have
- * shared timeline events, representing their narrative relationships
- * in the murder mystery investigation.
- * 
- * @param characters Array of characters with connection data
- * @param lookupMaps Entity lookup maps for O(1) character resolution
- * @returns Array of character-to-character connection edges
- */
-export function createCharacterConnectionEdges(
-  characters: Character[],
-  lookupMaps: EntityLookupMaps
-): GraphEdge[] {
-  
-  const edges: GraphEdge[] = [];
-  const processedPairs = new Set<string>(); // Avoid duplicate edges
-  
-  characters.forEach(character => {
-    if (!character.connections || character.connections.length === 0) return;
-    
-    character.connections.forEach(connectedCharId => {
-      // Create a unique pair ID to avoid duplicates (A→B and B→A)
-      const pairId = [character.id, connectedCharId].sort().join('-');
-      if (processedPairs.has(pairId)) return;
-      processedPairs.add(pairId);
-      
-      // Check if connected character exists
-      const connectedChar = lookupMaps.characters.get(connectedCharId);
-      
-      if (connectedChar) {
-        // Create bidirectional edge for character connections
-        const edge = createEdge(
-          character.id,
-          connectedCharId,
-          RELATIONSHIP_TYPES.CONNECTION, // Using constant for character connections
-          undefined,
-          undefined,
-          { weight: 0.7 } // Medium weight for character connections
-        );
-        
-        if (edge) {
-          edges.push(edge as GraphEdge);
-        }
-      }
-      // Skip edge creation if connected character doesn't exist (no warning needed)
-    });
-  });
-  
-  console.info(`Created ${edges.length} character connection edges`);
-  if (edges.length > 0) {
-    console.debug('Character connection edges:', edges.map(e => ({
-      from: characters.find(c => c.id === e.source)?.name || e.source,
-      to: characters.find(c => c.id === e.target)?.name || e.target
-    })));
-  }
-  
-  return edges;
-}
-
-// ============================================================================
-// Main Relationship Resolution
-// ============================================================================
-
-/**
- * Data integrity report for missing entities
- */
-export interface DataIntegrityReport {
-  missingEntities: Map<string, { type: EntityType; referencedBy: string[] }>;
-  brokenRelationships: number;
-  totalRelationships: number;
-  integrityScore: number; // 0-100 percentage
-}
-
-/**
- * Resolve all relationships and create comprehensive edge network for murder mystery investigation.
- * 
- * Orchestrates the creation of all relationship types between investigation entities (characters,
- * elements, puzzles, timeline events) using smart edge weighting and affinity analysis to
- * build a complete investigation graph for murder mystery visualization and analysis.
- * 
- * **Comprehensive Relationship Resolution:**
- * - **Ownership Edges**: Characters to owned elements with possession tracking
- * - **Requirement Edges**: Puzzles to required elements with dependency analysis
- * - **Reward Edges**: Puzzles to reward elements with motivation tracking
- * - **Timeline Edges**: Elements to timeline events with temporal correlation
- * - **Container Edges**: Elements to contained elements with nested evidence tracking
- * 
- * **Smart Edge Weighting Features:**
- * - Uses EdgeBuilder with intelligent weight calculation based on relationship strength
- * - Analyzes element affinity for dual-role and multi-puzzle element identification
- * - Provides comprehensive edge statistics and weight distribution analysis
- * - Optimizes edge rendering priority for investigation visualization
- * 
- * **Backward Compatibility:**
- * - Maintains original function signature for existing graph consumers
- * - Provides legacy edge format while using modern EdgeBuilder internally
- * - Preserves investigation workflow compatibility with existing systems
- * 
- * @param characters Array of investigation characters (suspects, witnesses)
- * @param elements Array of story elements (evidence, items, clues)
- * @param puzzles Array of investigation puzzles and challenges
- * @param timeline Array of timeline events for temporal investigation
- * @param nodes Optional graph nodes for enhanced affinity analysis
- * @returns Complete array of relationship edges for investigation graph
- * 
- * @complexity O(E + P + T + C) where E=elements, P=puzzles, T=timeline, C=characters
- * 
- * @example
- * ```typescript
- * // Complete relationship resolution for investigation graph
- * const characters = await getCharacters();
- * const elements = await getElements();
- * const puzzles = await getPuzzles();
- * const timeline = await getTimeline();
- * const nodes = existingGraphNodes; // Optional for affinity analysis
- * 
- * const allEdges = resolveAllRelationships(
- *   characters,
- *   elements,
- *   puzzles,
- *   timeline,
- *   nodes
- * );
- * 
- * console.log('Complete investigation network:', {
- *   totalEdges: allEdges.length,
- *   edgeTypes: [...new Set(allEdges.map(e => e.data.relationshipType))],
- *   averageWeight: allEdges.reduce((sum, e) => sum + (e.data.weight || 1), 0) / allEdges.length
- * });
- * 
- * // Analyze investigation network structure
- * const analyzeNetworkStructure = (edges: GraphEdge[]) => {
- *   const typeDistribution = edges.reduce((dist, edge) => {
- *     const type = edge.data.relationshipType;
- *     dist[type] = (dist[type] || 0) + 1;
- *     return dist;
- *   }, {} as Record<string, number>);
- *   
- *   return {
- *     totalRelationships: edges.length,
- *     relationshipTypes: typeDistribution,
- *     networkDensity: edges.length / ((characters.length + elements.length + puzzles.length + timeline.length) ** 2),
- *     investigationComplexity: Object.keys(typeDistribution).length
- *   };
- * };
- * 
- * // Investigation progression analysis
- * const trackInvestigationProgress = (completedElements: string[]) => {
- *   const availablePuzzles = allEdges
- *     .filter(edge => edge.data.relationshipType === 'requirement')
- *     .filter(edge => completedElements.includes(edge.source))
- *     .map(edge => edge.target);
- *   
- *   return {
- *     unlockedPuzzles: [...new Set(availablePuzzles)],
- *     progressPercentage: (completedElements.length / elements.length) * 100
- *   };
- * };
- * ```
- * 
- * @see {@link EdgeBuilder} For smart edge weighting and affinity analysis
- * @see {@link buildLookupMaps} For entity resolution optimization
- * @see {@link createOwnershipEdges} For ownership relationship creation
- * @see {@link createRequirementEdges} For puzzle dependency relationships
- * @see {@link createRewardEdges} For puzzle reward relationships
- * @see {@link createTimelineEdges} For temporal relationships
- * @see {@link createContainerEdges} For containment relationships
- * 
- * @remarks
- * **Investigation Workflow Integration:**
- * - Central function for complete investigation graph construction
- * - Provides foundation for all investigation visualization and analysis features
- * - Enables investigation progression tracking and puzzle dependency analysis
- * - Supports murder mystery investigation workflow optimization and player guidance
- * 
- * **Performance Characteristics:**
- * - Efficient O(1) entity lookups through optimized Map structures
- * - Smart edge weighting reduces rendering overhead for complex networks
- * - Affinity analysis provides investigation insights with minimal performance impact
- * - Comprehensive logging for investigation debugging and optimization
- */
-export function resolveAllRelationships(
-  characters: Character[],
-  elements: Element[],
-  puzzles: Puzzle[],
-  timeline: TimelineEvent[]
-): GraphEdge[] {
-  // Removed console.log to prevent console spam during infinite loop
-
-  // Build lookup maps for efficient resolution
-  const lookupMaps = buildLookupMaps(characters, elements, puzzles, timeline);
-  
-  // Create all edge types directly using the refactored functions
-  const ownershipEdges = createOwnershipEdges(elements, lookupMaps);
-  const requirementEdges = createRequirementEdges(puzzles, lookupMaps);
-  const rewardEdges = createRewardEdges(puzzles, lookupMaps);
-  const timelineEdges = createTimelineEdges(elements, lookupMaps);
-  const containerEdges = createContainerEdges(elements, lookupMaps);
-  const characterPuzzleEdges = createCharacterPuzzleEdges(characters, lookupMaps);
-  const characterConnectionEdges = createCharacterConnectionEdges(characters, lookupMaps);
-  
-  // Removed console.log to prevent console spam during infinite loop
-  
-  // Combine all edges
-  const allEdges = [
-    ...ownershipEdges,
-    ...requirementEdges,
-    ...rewardEdges,
-    ...timelineEdges,
-    ...containerEdges,
-    ...characterPuzzleEdges,
-    ...characterConnectionEdges
-  ];
-  
-  // Removed console.log statements to prevent console spam during infinite loop
-  
-  return allEdges;
-}
-
-/**
- * Filter edges by relationship type
- */
-export function filterEdgesByType(
-  edges: GraphEdge[],
-  types: RelationshipType[]
-): GraphEdge[] {
-  return edges.filter(edge => 
-    types.includes(edge.data?.relationshipType as RelationshipType)
-  );
-}
-
-/**
- * Get edges connected to a specific node
- */
-export function getConnectedEdges(
-  nodeId: string,
-  edges: GraphEdge[]
-): {
-  incoming: GraphEdge[];
-  outgoing: GraphEdge[];
-} {
-  return {
-    incoming: edges.filter(e => e.target === nodeId),
-    outgoing: edges.filter(e => e.source === nodeId),
-  };
-}
-
-/**
- * Calculate node connectivity score
- */
-export function calculateConnectivity(
-  nodeId: string,
-  edges: GraphEdge[]
-): number {
-  const connected = getConnectedEdges(nodeId, edges);
-  return connected.incoming.length + connected.outgoing.length;
-}
\ No newline at end of file
diff --git a/src/lib/queryClient.ts b/src/lib/queryClient.ts
index b76aaae..6f2e80b 100644
--- a/src/lib/queryClient.ts
+++ b/src/lib/queryClient.ts
@@ -1,5 +1,4 @@
 import { QueryClient, QueryCache, MutationCache } from '@tanstack/react-query'
-import { cacheVersionManager } from '@/lib/cache/CacheVersionManager'
 
 
 
@@ -95,15 +94,12 @@ export const queryClient = new QueryClient({
   },
 })
 
-// Initialize CacheVersionManager with the QueryClient
-cacheVersionManager.initialize(queryClient)
 
 // Helper function to reset the query client (useful for tests and logout)
 export const resetQueryClient = () => {
   queryClient.clear()
   queryClient.resetQueries()
   queryClient.removeQueries()
-  cacheVersionManager.reset()
 }
 
 // Helper function to prefetch common queries on app load
diff --git a/src/services/api.ts b/src/services/api.ts
index 64e829e..46afcfa 100644
--- a/src/services/api.ts
+++ b/src/services/api.ts
@@ -20,7 +20,6 @@ import type {
   TimelineEvent,
 } from '@/types/notion/app';
 import { requestBatcher } from './requestBatcher';
-import { cacheVersionManager } from '@/lib/cache/CacheVersionManager';
 
 /**
  * Metadata for atomic parent relationship creation.
@@ -151,7 +150,6 @@ async function fetcherImpl<T>(
 
   const headers: Record<string, string> = {
     'Content-Type': 'application/json',
-    ...cacheVersionManager.getRequestHeaders(), // Add cache version headers
   };
 
   // Only send API key header if we have one (for local dev)
@@ -179,8 +177,6 @@ async function fetcherImpl<T>(
     );
   }
 
-  // Process cache version headers
-  cacheVersionManager.processResponseHeaders(response.headers);
   
   const data = await response.json();
 
diff --git a/src/stores/filterStore.ts b/src/stores/filterStore.ts
index fa2121e..7e4b72a 100644
--- a/src/stores/filterStore.ts
+++ b/src/stores/filterStore.ts
@@ -41,6 +41,18 @@ import { subscribeWithSelector } from 'zustand/middleware';
 import { urlToFilterState, filterStateToUrl, updateBrowserUrl } from '@/utils/urlState';
 import type { ViewConfig } from '@/lib/viewConfigs';
 
+/**
+ * Default entity visibility configuration.
+ * Single source of truth for initial state and filter resets.
+ * Timeline is hidden by default to reduce visual clutter.
+ */
+const DEFAULT_ENTITY_VISIBILITY = {
+  character: true,
+  puzzle: true,
+  element: true,
+  timeline: false,  // Hidden by default until user explicitly enables
+};
+
 /**
  * Puzzle-specific filter configuration.
  * @interface PuzzleFilters
@@ -117,18 +129,15 @@ export interface FilterState {
   // Universal filters
   searchTerm: string;
   selectedNodeId: string | null; // Universal node selection (search, click, detail panel)
-  focusedNodeId: string | null; // Node for connection depth filtering
   
   // Graph view settings (universal across views)
   connectionDepth: number;
-  filterMode: 'pure' | 'connected' | 'focused'; // How depth filtering behaves
-  focusRespectFilters: boolean; // Whether focus mode respects entity filters or shows all connections
   
   // Entity visibility toggles (Option 2)
   entityVisibility: {
-    characters: boolean;
-    puzzles: boolean;
-    elements: boolean;
+    character: boolean;
+    puzzle: boolean;
+    element: boolean;
     timeline: boolean;
   };
   
@@ -152,16 +161,13 @@ export interface FilterActions {
   setSearchTerm: (term: string) => void;
   clearSearch: () => void;
   setSelectedNode: (nodeId: string | null) => void;
-  setFocusedNode: (nodeId: string | null) => void;
   
   // Graph view settings actions
   setConnectionDepth: (depth: number) => void;
-  setFilterMode: (mode: 'pure' | 'connected' | 'focused') => void;
-  setFocusRespectFilters: (respect: boolean) => void;
   
   // Entity visibility actions (Option 2)
-  toggleEntityVisibility: (entityType: 'characters' | 'puzzles' | 'elements' | 'timeline') => void;
-  setEntityVisibility: (entityType: 'characters' | 'puzzles' | 'elements' | 'timeline', visible: boolean) => void;
+  toggleEntityVisibility: (entityType: 'character' | 'puzzle' | 'element' | 'timeline') => void;
+  setEntityVisibility: (entityType: 'character' | 'puzzle' | 'element' | 'timeline', visible: boolean) => void;
   showAllEntities: () => void;
   hideAllEntities: () => void;
   
@@ -268,16 +274,8 @@ export const useFilterStore = create<FilterStore>()(
         // Initial state
         searchTerm: '',
         selectedNodeId: null,
-        focusedNodeId: null,
         connectionDepth: 3, // Default to 3 hops
-        filterMode: 'connected' as const, // Default to connected mode
-        focusRespectFilters: true, // Default to respecting filters in focus mode
-        entityVisibility: {
-          characters: true,
-          puzzles: true,
-          elements: true,
-          timeline: true,
-        },
+        entityVisibility: DEFAULT_ENTITY_VISIBILITY,
         puzzleFilters: {
           selectedActs: new Set(),
           selectedPuzzleId: null,
@@ -304,33 +302,9 @@ export const useFilterStore = create<FilterStore>()(
         setSearchTerm: (term) => set({ searchTerm: term }),
         clearSearch: () => set({ searchTerm: '' }),
         setSelectedNode: (nodeId) => set({ selectedNodeId: nodeId }),
-        setFocusedNode: (nodeId) => {
-          // Update filter mode when focus changes
-          const state = get();
-          if (nodeId) {
-            // When a node is focused, switch to focused mode
-            set({ focusedNodeId: nodeId, filterMode: 'focused' });
-          } else {
-            // When focus is cleared, switch back based on depth
-            const newMode = state.connectionDepth === 0 ? 'pure' : 'connected';
-            set({ focusedNodeId: nodeId, filterMode: newMode });
-          }
-        },
 
         // Graph view settings actions
-        setConnectionDepth: (depth) => {
-          // Automatically set filter mode based on depth and focus state
-          const state = get();
-          if (depth === 0) {
-            set({ connectionDepth: depth, filterMode: 'pure' });
-          } else if (state.focusedNodeId) {
-            set({ connectionDepth: depth, filterMode: 'focused' });
-          } else {
-            set({ connectionDepth: depth, filterMode: 'connected' });
-          }
-        },
-        setFilterMode: (mode) => set({ filterMode: mode }),
-        setFocusRespectFilters: (respect) => set({ focusRespectFilters: respect }),
+        setConnectionDepth: (depth) => set({ connectionDepth: depth }),
         
         // Entity visibility actions (Option 2)
         toggleEntityVisibility: (entityType) => set((state) => ({
@@ -347,17 +321,17 @@ export const useFilterStore = create<FilterStore>()(
         })),
         showAllEntities: () => set({
           entityVisibility: {
-            characters: true,
-            puzzles: true,
-            elements: true,
+            character: true,
+            puzzle: true,
+            element: true,
             timeline: true
           }
         }),
         hideAllEntities: () => set({
           entityVisibility: {
-            characters: false,
-            puzzles: false,
-            elements: false,
+            character: false,
+            puzzle: false,
+            element: false,
             timeline: false
           }
         }),
@@ -470,15 +444,8 @@ export const useFilterStore = create<FilterStore>()(
         clearAllFilters: () => set({
           searchTerm: '',
           selectedNodeId: null,
-          focusedNodeId: null,
           connectionDepth: 3,
-          filterMode: 'connected',
-          entityVisibility: {
-            characters: true,
-            puzzles: true,
-            elements: true,
-            timeline: true,
-          },
+          entityVisibility: DEFAULT_ENTITY_VISIBILITY,
           puzzleFilters: {
             selectedActs: new Set(),
             selectedPuzzleId: null,
@@ -794,8 +761,7 @@ export const useFilterStore = create<FilterStore>()(
             state.contentFilters.hasIssues !== null ||
             state.contentFilters.lastEditedRange !== 'all' ||
             state.contentFilters.elementBasicTypes.size > 0 ||
-            state.contentFilters.elementStatus.size > 0 ||
-            state.focusedNodeId !== null
+            state.contentFilters.elementStatus.size > 0
           );
         },
 
@@ -817,7 +783,6 @@ export const useFilterStore = create<FilterStore>()(
           if (state.contentFilters.lastEditedRange !== 'all') count++;
           count += state.contentFilters.elementBasicTypes.size;
           count += state.contentFilters.elementStatus.size;
-          if (state.focusedNodeId) count++;
           
           return count;
         },        getActiveFiltersForView: () => {
@@ -874,8 +839,8 @@ export const useFilterStore = create<FilterStore>()(
               if (state.nodeConnectionsFilters?.nodeType) {
                 filters.push(`Type: ${state.nodeConnectionsFilters.nodeType}`);
               }
-              if (state.focusedNodeId) {
-                filters.push('Node focused');
+              if (state.selectedNodeId) {
+                filters.push('Node selected');
               }
               break;
           }
diff --git a/src/types/notion/app.ts b/src/types/notion/app.ts
index 1be9e7b..1a199fb 100644
--- a/src/types/notion/app.ts
+++ b/src/types/notion/app.ts
@@ -185,6 +185,7 @@ export interface TimelineEvent {
   memTypes: ElementBasicType[]; // From rollup
   notes: string;
   lastEditedTime: string;
+  associatedPuzzles?: string[]; // Synthesized from puzzle.storyReveals
 }
 
 // API response types
diff --git a/src/utils/urlState.ts b/src/utils/urlState.ts
index 3397266..4fea3e3 100644
--- a/src/utils/urlState.ts
+++ b/src/utils/urlState.ts
@@ -126,10 +126,6 @@ export function filterStateToUrl(state: FilterState): URLSearchParams {
     params.set('selectedNodeId', state.selectedNodeId);
   }
   
-  if (state.focusedNodeId) {
-    params.set('focusedNodeId', state.focusedNodeId);
-  }
-  
   return params;
 }
 
@@ -267,11 +263,6 @@ export function urlToFilterState(params: URLSearchParams): Partial<FilterState>
     state.selectedNodeId = selectedNodeId;
   }
   
-  const focusedNodeId = params.get('focusedNodeId');
-  if (focusedNodeId) {
-    state.focusedNodeId = focusedNodeId;
-  }
-  
   return state;
 }
 
diff --git a/unused-exports.txt b/unused-exports.txt
deleted file mode 100644
index e69de29..0000000
